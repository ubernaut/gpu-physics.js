{"version":3,"file":"webgpu-physics.js","sources":["../src/math.ts","../src/device.ts","../src/shaders/shared.wgsl?raw","../src/shaders/local_to_world.wgsl?raw","../src/shaders/local_to_relative.wgsl?raw","../src/shaders/body_vel_to_particle_vel.wgsl?raw","../src/shaders/clear_grid.wgsl?raw","../src/shaders/build_grid.wgsl?raw","../src/shaders/update_force.wgsl?raw","../src/shaders/update_torque.wgsl?raw","../src/shaders/reduce_force.wgsl?raw","../src/shaders/reduce_torque.wgsl?raw","../src/shaders/update_body_velocity.wgsl?raw","../src/shaders/update_body_angular_velocity.wgsl?raw","../src/shaders/update_body_position.wgsl?raw","../src/shaders/update_body_quaternion.wgsl?raw","../src/world.ts","../src/index.ts"],"sourcesContent":["/**\n * Math utilities for WebGPU Physics\n * Provides vector, quaternion, and matrix operations\n */\n\n/**\n * 3D Vector class\n */\nexport class Vec3 {\n  public data: Float32Array;\n\n  constructor(x = 0, y = 0, z = 0) {\n    this.data = new Float32Array([x, y, z]);\n  }\n\n  get x(): number { return this.data[0]; }\n  set x(v: number) { this.data[0] = v; }\n  get y(): number { return this.data[1]; }\n  set y(v: number) { this.data[1] = v; }\n  get z(): number { return this.data[2]; }\n  set z(v: number) { this.data[2] = v; }\n\n  set(x: number, y: number, z: number): Vec3 {\n    this.data[0] = x;\n    this.data[1] = y;\n    this.data[2] = z;\n    return this;\n  }\n\n  copy(v: Vec3): Vec3 {\n    this.data[0] = v.data[0];\n    this.data[1] = v.data[1];\n    this.data[2] = v.data[2];\n    return this;\n  }\n\n  clone(): Vec3 {\n    return new Vec3(this.x, this.y, this.z);\n  }\n\n  add(v: Vec3): Vec3 {\n    this.data[0] += v.data[0];\n    this.data[1] += v.data[1];\n    this.data[2] += v.data[2];\n    return this;\n  }\n\n  sub(v: Vec3): Vec3 {\n    this.data[0] -= v.data[0];\n    this.data[1] -= v.data[1];\n    this.data[2] -= v.data[2];\n    return this;\n  }\n\n  scale(s: number): Vec3 {\n    this.data[0] *= s;\n    this.data[1] *= s;\n    this.data[2] *= s;\n    return this;\n  }\n\n  dot(v: Vec3): number {\n    return this.data[0] * v.data[0] + this.data[1] * v.data[1] + this.data[2] * v.data[2];\n  }\n\n  cross(v: Vec3): Vec3 {\n    const ax = this.data[0], ay = this.data[1], az = this.data[2];\n    const bx = v.data[0], by = v.data[1], bz = v.data[2];\n    this.data[0] = ay * bz - az * by;\n    this.data[1] = az * bx - ax * bz;\n    this.data[2] = ax * by - ay * bx;\n    return this;\n  }\n\n  length(): number {\n    return Math.sqrt(this.dot(this));\n  }\n\n  lengthSq(): number {\n    return this.dot(this);\n  }\n\n  normalize(): Vec3 {\n    const len = this.length();\n    if (len > 0) {\n      this.scale(1 / len);\n    }\n    return this;\n  }\n\n  static cross(a: Vec3, b: Vec3, out?: Vec3): Vec3 {\n    out = out || new Vec3();\n    out.data[0] = a.y * b.z - a.z * b.y;\n    out.data[1] = a.z * b.x - a.x * b.z;\n    out.data[2] = a.x * b.y - a.y * b.x;\n    return out;\n  }\n\n  static dot(a: Vec3, b: Vec3): number {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n  }\n}\n\n/**\n * 4D Vector class\n */\nexport class Vec4 {\n  public data: Float32Array;\n\n  constructor(x = 0, y = 0, z = 0, w = 0) {\n    this.data = new Float32Array([x, y, z, w]);\n  }\n\n  get x(): number { return this.data[0]; }\n  set x(v: number) { this.data[0] = v; }\n  get y(): number { return this.data[1]; }\n  set y(v: number) { this.data[1] = v; }\n  get z(): number { return this.data[2]; }\n  set z(v: number) { this.data[2] = v; }\n  get w(): number { return this.data[3]; }\n  set w(v: number) { this.data[3] = v; }\n\n  set(x: number, y: number, z: number, w: number): Vec4 {\n    this.data[0] = x;\n    this.data[1] = y;\n    this.data[2] = z;\n    this.data[3] = w;\n    return this;\n  }\n\n  copy(v: Vec4): Vec4 {\n    this.data[0] = v.data[0];\n    this.data[1] = v.data[1];\n    this.data[2] = v.data[2];\n    this.data[3] = v.data[3];\n    return this;\n  }\n\n  clone(): Vec4 {\n    return new Vec4(this.x, this.y, this.z, this.w);\n  }\n}\n\n/**\n * Quaternion class for rotations\n */\nexport class Quat {\n  public data: Float32Array;\n\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this.data = new Float32Array([x, y, z, w]);\n  }\n\n  get x(): number { return this.data[0]; }\n  set x(v: number) { this.data[0] = v; }\n  get y(): number { return this.data[1]; }\n  set y(v: number) { this.data[1] = v; }\n  get z(): number { return this.data[2]; }\n  set z(v: number) { this.data[2] = v; }\n  get w(): number { return this.data[3]; }\n  set w(v: number) { this.data[3] = v; }\n\n  set(x: number, y: number, z: number, w: number): Quat {\n    this.data[0] = x;\n    this.data[1] = y;\n    this.data[2] = z;\n    this.data[3] = w;\n    return this;\n  }\n\n  copy(q: Quat): Quat {\n    this.data[0] = q.data[0];\n    this.data[1] = q.data[1];\n    this.data[2] = q.data[2];\n    this.data[3] = q.data[3];\n    return this;\n  }\n\n  clone(): Quat {\n    return new Quat(this.x, this.y, this.z, this.w);\n  }\n\n  identity(): Quat {\n    return this.set(0, 0, 0, 1);\n  }\n\n  length(): number {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n\n  normalize(): Quat {\n    const len = this.length();\n    if (len > 0) {\n      const invLen = 1 / len;\n      this.data[0] *= invLen;\n      this.data[1] *= invLen;\n      this.data[2] *= invLen;\n      this.data[3] *= invLen;\n    }\n    return this;\n  }\n\n  /**\n   * Integrate quaternion with angular velocity\n   * Matches the original GLSL quat_integrate function\n   */\n  integrate(angularVelocity: Vec3, dt: number): Quat {\n    const halfDt = dt * 0.5;\n    const wx = angularVelocity.x;\n    const wy = angularVelocity.y;\n    const wz = angularVelocity.z;\n\n    this.data[0] += halfDt * (wx * this.w + wy * this.z - wz * this.y);\n    this.data[1] += halfDt * (wy * this.w + wz * this.x - wx * this.z);\n    this.data[2] += halfDt * (wz * this.w + wx * this.y - wy * this.x);\n    this.data[3] += halfDt * (-wx * this.x - wy * this.y - wz * this.z);\n\n    return this.normalize();\n  }\n\n  /**\n   * Apply quaternion rotation to a vector\n   * Matches the original GLSL vec3_applyQuat function\n   */\n  applyToVec3(v: Vec3, out?: Vec3): Vec3 {\n    out = out || new Vec3();\n    \n    const x = v.x, y = v.y, z = v.z;\n    const qx = this.x, qy = this.y, qz = this.z, qw = this.w;\n\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n\n    out.data[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out.data[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out.data[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n    return out;\n  }\n\n  /**\n   * Set quaternion from axis-angle representation\n   */\n  setFromAxisAngle(axis: Vec3, angle: number): Quat {\n    const halfAngle = angle * 0.5;\n    const s = Math.sin(halfAngle);\n    this.data[0] = axis.x * s;\n    this.data[1] = axis.y * s;\n    this.data[2] = axis.z * s;\n    this.data[3] = Math.cos(halfAngle);\n    return this;\n  }\n\n  /**\n   * Multiply this quaternion by another\n   */\n  multiply(q: Quat): Quat {\n    const ax = this.x, ay = this.y, az = this.z, aw = this.w;\n    const bx = q.x, by = q.y, bz = q.z, bw = q.w;\n\n    this.data[0] = ax * bw + aw * bx + ay * bz - az * by;\n    this.data[1] = ay * bw + aw * by + az * bx - ax * bz;\n    this.data[2] = az * bw + aw * bz + ax * by - ay * bx;\n    this.data[3] = aw * bw - ax * bx - ay * by - az * bz;\n\n    return this;\n  }\n\n  /**\n   * Spherical linear interpolation\n   */\n  static slerp(a: Quat, b: Quat, t: number, out?: Quat): Quat {\n    out = out || new Quat();\n    \n    let d = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n    \n    // If negative dot, negate one quaternion\n    let bx = b.x, by = b.y, bz = b.z, bw = b.w;\n    if (d < 0) {\n      bx = -bx; by = -by; bz = -bz; bw = -bw;\n      d = -d;\n    }\n\n    if (d > 0.9995) {\n      // Linear interpolation for close quaternions\n      out.data[0] = a.x + t * (bx - a.x);\n      out.data[1] = a.y + t * (by - a.y);\n      out.data[2] = a.z + t * (bz - a.z);\n      out.data[3] = a.w + t * (bw - a.w);\n      return out.normalize();\n    }\n\n    const theta0 = Math.acos(d);\n    const theta = theta0 * t;\n    const sinTheta = Math.sin(theta);\n    const sinTheta0 = Math.sin(theta0);\n\n    const s0 = Math.cos(theta) - d * sinTheta / sinTheta0;\n    const s1 = sinTheta / sinTheta0;\n\n    out.data[0] = a.x * s0 + bx * s1;\n    out.data[1] = a.y * s0 + by * s1;\n    out.data[2] = a.z * s0 + bz * s1;\n    out.data[3] = a.w * s0 + bw * s1;\n\n    return out;\n  }\n}\n\n/**\n * 3x3 Matrix class (column-major storage)\n */\nexport class Mat3 {\n  public data: Float32Array;\n\n  constructor() {\n    this.data = new Float32Array(9);\n    this.identity();\n  }\n\n  identity(): Mat3 {\n    this.data.fill(0);\n    this.data[0] = 1;\n    this.data[4] = 1;\n    this.data[8] = 1;\n    return this;\n  }\n\n  /**\n   * Create rotation matrix from quaternion\n   * Matches the original GLSL quat2mat function\n   */\n  fromQuat(q: Quat): Mat3 {\n    const x = q.x, y = q.y, z = q.z, w = q.w;\n    const x2 = x + x, y2 = y + y, z2 = z + z;\n    const xx = x * x2, xy = x * y2, xz = x * z2;\n    const yy = y * y2, yz = y * z2, zz = z * z2;\n    const wx = w * x2, wy = w * y2, wz = w * z2;\n\n    // Column-major layout\n    this.data[0] = 1 - (yy + zz);\n    this.data[1] = xy + wz;\n    this.data[2] = xz - wy;\n\n    this.data[3] = xy - wz;\n    this.data[4] = 1 - (xx + zz);\n    this.data[5] = yz + wx;\n\n    this.data[6] = xz + wy;\n    this.data[7] = yz - wx;\n    this.data[8] = 1 - (xx + yy);\n\n    return this;\n  }\n\n  /**\n   * Transpose in place\n   */\n  transpose(): Mat3 {\n    const m = this.data;\n    let tmp: number;\n    tmp = m[1]; m[1] = m[3]; m[3] = tmp;\n    tmp = m[2]; m[2] = m[6]; m[6] = tmp;\n    tmp = m[5]; m[5] = m[7]; m[7] = tmp;\n    return this;\n  }\n\n  /**\n   * Multiply two matrices: this = this * b\n   */\n  multiply(b: Mat3): Mat3 {\n    const a = this.data;\n    const ae = [...a]; // Copy\n    const be = b.data;\n\n    a[0] = ae[0] * be[0] + ae[3] * be[1] + ae[6] * be[2];\n    a[1] = ae[1] * be[0] + ae[4] * be[1] + ae[7] * be[2];\n    a[2] = ae[2] * be[0] + ae[5] * be[1] + ae[8] * be[2];\n\n    a[3] = ae[0] * be[3] + ae[3] * be[4] + ae[6] * be[5];\n    a[4] = ae[1] * be[3] + ae[4] * be[4] + ae[7] * be[5];\n    a[5] = ae[2] * be[3] + ae[5] * be[4] + ae[8] * be[5];\n\n    a[6] = ae[0] * be[6] + ae[3] * be[7] + ae[6] * be[8];\n    a[7] = ae[1] * be[6] + ae[4] * be[7] + ae[7] * be[8];\n    a[8] = ae[2] * be[6] + ae[5] * be[7] + ae[8] * be[8];\n\n    return this;\n  }\n\n  /**\n   * Apply matrix to vector\n   */\n  applyToVec3(v: Vec3, out?: Vec3): Vec3 {\n    out = out || new Vec3();\n    const m = this.data;\n    const x = v.x, y = v.y, z = v.z;\n    out.data[0] = m[0] * x + m[3] * y + m[6] * z;\n    out.data[1] = m[1] * x + m[4] * y + m[7] * z;\n    out.data[2] = m[2] * x + m[5] * y + m[8] * z;\n    return out;\n  }\n\n  /**\n   * Create diagonal matrix from vector\n   */\n  setDiagonal(v: Vec3): Mat3 {\n    this.data.fill(0);\n    this.data[0] = v.x;\n    this.data[4] = v.y;\n    this.data[8] = v.z;\n    return this;\n  }\n\n  clone(): Mat3 {\n    const m = new Mat3();\n    m.data.set(this.data);\n    return m;\n  }\n}\n\n/**\n * Calculate world-space inverse inertia tensor\n * Matches the original GLSL invInertiaWorld function\n */\nexport function computeWorldInverseInertia(q: Quat, invInertia: Vec3, out?: Mat3): Mat3 {\n  out = out || new Mat3();\n  \n  const R = new Mat3().fromQuat(q);\n  const I = new Mat3().setDiagonal(invInertia);\n  const RT = R.clone().transpose();\n  \n  // invI_world = R^T * I * R\n  out.data.set(RT.multiply(I).multiply(R).data);\n  \n  return out;\n}\n\n/**\n * Calculate box inertia tensor from mass and extents\n */\nexport function calculateBoxInertia(mass: number, extents: Vec3): Vec3 {\n  const c = (1 / 12) * mass;\n  const ex = 2 * extents.x;\n  const ey = 2 * extents.y;\n  const ez = 2 * extents.z;\n  return new Vec3(\n    c * (ey * ey + ez * ez),\n    c * (ex * ex + ez * ez),\n    c * (ex * ex + ey * ey)\n  );\n}\n","/**\n * WebGPU Device initialization and management\n */\n\n/**\n * WebGPU context containing device and adapter\n */\nexport interface WebGPUContext {\n  adapter: GPUAdapter;\n  device: GPUDevice;\n  features: GPUSupportedFeatures;\n  limits: GPUSupportedLimits;\n}\n\n/**\n * Check if WebGPU is supported in the current environment\n */\nexport function isWebGPUSupported(): boolean {\n  return typeof navigator !== 'undefined' && 'gpu' in navigator;\n}\n\n/**\n * Initialize WebGPU and request a device\n * @throws Error if WebGPU is not supported or device creation fails\n */\nexport async function initWebGPU(): Promise<WebGPUContext> {\n  if (!isWebGPUSupported()) {\n    throw new Error('WebGPU is not supported in this browser. Please use a WebGPU-enabled browser like Chrome 113+ or Edge 113+.');\n  }\n\n  const gpu = navigator.gpu;\n  \n  // Request adapter\n  const adapter = await gpu.requestAdapter({\n    powerPreference: 'high-performance'\n  });\n\n  if (!adapter) {\n    throw new Error('Failed to get WebGPU adapter. Your GPU may not support WebGPU.');\n  }\n\n  // Log adapter info for debugging\n  const adapterInfo = adapter.info;\n  console.log('WebGPU Adapter:', {\n    vendor: adapterInfo.vendor,\n    architecture: adapterInfo.architecture,\n    device: adapterInfo.device,\n    description: adapterInfo.description\n  });\n\n  // Request device with required features\n  const requiredFeatures: GPUFeatureName[] = [];\n  const requiredLimits: Record<string, number> = {\n    maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,\n    maxComputeWorkgroupsPerDimension: adapter.limits.maxComputeWorkgroupsPerDimension,\n    maxComputeInvocationsPerWorkgroup: adapter.limits.maxComputeInvocationsPerWorkgroup,\n    maxComputeWorkgroupSizeX: adapter.limits.maxComputeWorkgroupSizeX,\n    maxComputeWorkgroupSizeY: adapter.limits.maxComputeWorkgroupSizeY,\n    maxComputeWorkgroupSizeZ: adapter.limits.maxComputeWorkgroupSizeZ,\n  };\n\n  // Check for timestamp query support (useful for profiling)\n  if (adapter.features.has('timestamp-query')) {\n    requiredFeatures.push('timestamp-query');\n  }\n\n  const device = await adapter.requestDevice({\n    requiredFeatures,\n    requiredLimits\n  });\n\n  // Handle device loss\n  device.lost.then((info) => {\n    console.error('WebGPU device lost:', info.message);\n    if (info.reason !== 'destroyed') {\n      // Could attempt to recreate device here\n      console.error('Device loss reason:', info.reason);\n    }\n  });\n\n  // Set up error handling\n  device.onuncapturederror = (event) => {\n    console.error('WebGPU uncaptured error:', event.error);\n  };\n\n  return {\n    adapter,\n    device,\n    features: device.features,\n    limits: device.limits\n  };\n}\n\n/**\n * Create a compute shader module from WGSL source\n */\nexport function createShaderModule(device: GPUDevice, code: string, label?: string): GPUShaderModule {\n  return device.createShaderModule({\n    label: label || 'shader',\n    code\n  });\n}\n\n/**\n * Create a compute pipeline\n */\nexport function createComputePipeline(\n  device: GPUDevice,\n  shaderModule: GPUShaderModule,\n  entryPoint: string,\n  layout: GPUPipelineLayout | 'auto',\n  label?: string\n): GPUComputePipeline {\n  return device.createComputePipeline({\n    label: label || 'compute-pipeline',\n    layout,\n    compute: {\n      module: shaderModule,\n      entryPoint\n    }\n  });\n}\n\n/**\n * Create a storage buffer\n */\nexport function createStorageBuffer(\n  device: GPUDevice,\n  size: number,\n  label?: string,\n  mappedAtCreation = false\n): GPUBuffer {\n  return device.createBuffer({\n    label: label || 'storage-buffer',\n    size,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    mappedAtCreation\n  });\n}\n\n/**\n * Create a uniform buffer\n */\nexport function createUniformBuffer(\n  device: GPUDevice,\n  size: number,\n  label?: string\n): GPUBuffer {\n  return device.createBuffer({\n    label: label || 'uniform-buffer',\n    size,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n  });\n}\n\n/**\n * Create a staging buffer for GPU->CPU readback\n */\nexport function createStagingBuffer(\n  device: GPUDevice,\n  size: number,\n  label?: string\n): GPUBuffer {\n  return device.createBuffer({\n    label: label || 'staging-buffer',\n    size,\n    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n  });\n}\n\n/**\n * Write data to a buffer\n */\nexport function writeBuffer(\n  device: GPUDevice,\n  buffer: GPUBuffer,\n  data: ArrayBuffer | ArrayBufferView,\n  offset = 0\n): void {\n  device.queue.writeBuffer(buffer, offset, data as ArrayBuffer);\n}\n\n/**\n * Read data from a buffer (async)\n */\nexport async function readBuffer(\n  device: GPUDevice,\n  sourceBuffer: GPUBuffer,\n  stagingBuffer: GPUBuffer,\n  size: number\n): Promise<ArrayBuffer> {\n  const commandEncoder = device.createCommandEncoder();\n  commandEncoder.copyBufferToBuffer(sourceBuffer, 0, stagingBuffer, 0, size);\n  device.queue.submit([commandEncoder.finish()]);\n\n  await stagingBuffer.mapAsync(GPUMapMode.READ);\n  const copyData = stagingBuffer.getMappedRange().slice(0);\n  stagingBuffer.unmap();\n\n  return copyData;\n}\n\n/**\n * Utility to align buffer sizes to GPU requirements\n */\nexport function alignTo(size: number, alignment: number): number {\n  return Math.ceil(size / alignment) * alignment;\n}\n\n/**\n * Get workgroup dispatch dimensions for a given number of elements\n */\nexport function getDispatchSize(numElements: number, workgroupSize: number): number {\n  return Math.ceil(numElements / workgroupSize);\n}\n","export default \"// Shared WGSL utilities for WebGPU Physics\\n\\n// Simulation parameters uniform buffer\\nstruct Params {\\n  // params1: stiffness, damping, radius, particleCount\\n  stiffness: f32,\\n  damping: f32,\\n  radius: f32,\\n  particleCount: f32,\\n  \\n  // params2: dt, friction, drag, bodyCount  \\n  dt: f32,\\n  friction: f32,\\n  drag: f32,\\n  bodyCount: f32,\\n  \\n  // gravity: x, y, z, 0\\n  gravity: vec4<f32>,\\n  \\n  // boxSize: x, y, z, 0\\n  boxSize: vec4<f32>,\\n  \\n  // gridPos: x, y, z, 0\\n  gridPos: vec4<f32>,\\n  \\n  // gridRes: x, y, z, maxParticlesPerCell\\n  gridRes: vec4<f32>,\\n  \\n  // sphereInteraction: x, y, z, radius\\n  sphere: vec4<f32>,\\n  \\n  // maxVelocity: x, y, z, 0\\n  maxVelocity: vec4<f32>,\\n}\\n\\n// Workgroup size constant\\nconst WORKGROUP_SIZE: u32 = 64u;\\n\\n// Get grid cell position from world position\\nfn worldPosToGridPos(particlePos: vec3<f32>, gridPos: vec3<f32>, cellSize: vec3<f32>) -> vec3<i32> {\\n  return vec3<i32>(floor((particlePos - gridPos) / cellSize));\\n}\\n\\n// Convert 3D grid position to linear index\\nfn gridPosToIndex(gridPos: vec3<i32>, gridRes: vec3<i32>) -> i32 {\\n  // Clamp to valid range\\n  let clamped = clamp(gridPos, vec3<i32>(0), gridRes - vec3<i32>(1));\\n  return clamped.x + clamped.y * gridRes.x + clamped.z * gridRes.x * gridRes.y;\\n}\\n\\n// Check if grid position is valid\\nfn isValidGridPos(gridPos: vec3<i32>, gridRes: vec3<i32>) -> bool {\\n  return gridPos.x >= 0 && gridPos.x < gridRes.x &&\\n         gridPos.y >= 0 && gridPos.y < gridRes.y &&\\n         gridPos.z >= 0 && gridPos.z < gridRes.z;\\n}\\n\\n// Quaternion multiplication\\nfn quatMul(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {\\n  return vec4<f32>(\\n    a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,\\n    a.w * b.y + a.y * b.w + a.z * b.x - a.x * b.z,\\n    a.w * b.z + a.z * b.w + a.x * b.y - a.y * b.x,\\n    a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z\\n  );\\n}\\n\\n// Integrate quaternion with angular velocity\\nfn quatIntegrate(q: vec4<f32>, w: vec3<f32>, dt: f32) -> vec4<f32> {\\n  let halfDt = dt * 0.5;\\n  \\n  var result = q;\\n  result.x += halfDt * (w.x * q.w + w.y * q.z - w.z * q.y);\\n  result.y += halfDt * (w.y * q.w + w.z * q.x - w.x * q.z);\\n  result.z += halfDt * (w.z * q.w + w.x * q.y - w.y * q.x);\\n  result.w += halfDt * (-w.x * q.x - w.y * q.y - w.z * q.z);\\n  \\n  return normalize(result);\\n}\\n\\n// Rotate vector by quaternion\\nfn quatRotate(v: vec3<f32>, q: vec4<f32>) -> vec3<f32> {\\n  let ix = q.w * v.x + q.y * v.z - q.z * v.y;\\n  let iy = q.w * v.y + q.z * v.x - q.x * v.z;\\n  let iz = q.w * v.z + q.x * v.y - q.y * v.x;\\n  let iw = -q.x * v.x - q.y * v.y - q.z * v.z;\\n  \\n  return vec3<f32>(\\n    ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y,\\n    iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z,\\n    iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x\\n  );\\n}\\n\\n// Quaternion to rotation matrix (3x3)\\nfn quatToMat3(q: vec4<f32>) -> mat3x3<f32> {\\n  let x = q.x;\\n  let y = q.y;\\n  let z = q.z;\\n  let w = q.w;\\n  \\n  let x2 = x + x;\\n  let y2 = y + y;\\n  let z2 = z + z;\\n  \\n  let xx = x * x2;\\n  let xy = x * y2;\\n  let xz = x * z2;\\n  let yy = y * y2;\\n  let yz = y * z2;\\n  let zz = z * z2;\\n  let wx = w * x2;\\n  let wy = w * y2;\\n  let wz = w * z2;\\n  \\n  return mat3x3<f32>(\\n    vec3<f32>(1.0 - (yy + zz), xy + wz, xz - wy),\\n    vec3<f32>(xy - wz, 1.0 - (xx + zz), yz + wx),\\n    vec3<f32>(xz + wy, yz - wx, 1.0 - (xx + yy))\\n  );\\n}\\n\\n// Compute world-space inverse inertia tensor\\nfn invInertiaWorld(q: vec4<f32>, invInertia: vec3<f32>) -> mat3x3<f32> {\\n  let R = quatToMat3(q);\\n  let RT = transpose(R);\\n  \\n  // Diagonal inverse inertia matrix\\n  let I = mat3x3<f32>(\\n    vec3<f32>(invInertia.x, 0.0, 0.0),\\n    vec3<f32>(0.0, invInertia.y, 0.0),\\n    vec3<f32>(0.0, 0.0, invInertia.z)\\n  );\\n  \\n  // R^T * I * R\\n  return RT * I * R;\\n}\\n\\n// Cross product\\nfn cross3(a: vec3<f32>, b: vec3<f32>) -> vec3<f32> {\\n  return vec3<f32>(\\n    a.y * b.z - a.z * b.y,\\n    a.z * b.x - a.x * b.z,\\n    a.x * b.y - a.y * b.x\\n  );\\n}\\n\\n// Particle contact force calculation (spring-damper model)\\nfn particleForce(\\n  stiffness: f32,\\n  damping: f32,\\n  friction: f32,\\n  distance: f32,\\n  minDistance: f32,\\n  xi: vec3<f32>,\\n  xj: vec3<f32>,\\n  vi: vec3<f32>,\\n  vj: vec3<f32>\\n) -> vec3<f32> {\\n  let rij = xj - xi;\\n  let len = length(rij);\\n  \\n  if (len < 0.0001) {\\n    return vec3<f32>(0.0);\\n  }\\n  \\n  let rijUnit = rij / len;\\n  let vij = vj - vi;\\n  let vijT = vij - dot(vij, rijUnit) * rijUnit;\\n  \\n  let springForce = -stiffness * (distance - max(len, minDistance)) * rijUnit;\\n  let dampingForce = damping * dot(vij, rijUnit) * rijUnit;\\n  let tangentForce = friction * vijT;\\n  \\n  return springForce + dampingForce + tangentForce;\\n}\\n\"","export default \"// Transform local particle positions to world space\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleLocalPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyPos: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> bodyQuat: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read_write> particleWorldPos: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let localPosAndBodyId = particleLocalPos[particleIndex];\\n  let localPos = localPosAndBodyId.xyz;\\n  let bodyId = u32(localPosAndBodyId.w);\\n  \\n  let bodyPosition = bodyPos[bodyId].xyz;\\n  let bodyQuaternion = bodyQuat[bodyId];\\n  \\n  // Rotate local position by body quaternion and add body position\\n  let worldPos = bodyPosition + quatRotate(localPos, bodyQuaternion);\\n  \\n  particleWorldPos[particleIndex] = vec4<f32>(worldPos, f32(bodyId));\\n}\\n\"","export default \"// Compute relative particle positions (for torque calculation)\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleLocalPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyPos: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> bodyQuat: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read_write> particleRelativePos: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let localPosAndBodyId = particleLocalPos[particleIndex];\\n  let localPos = localPosAndBodyId.xyz;\\n  let bodyId = u32(localPosAndBodyId.w);\\n  \\n  let bodyQuaternion = bodyQuat[bodyId];\\n  \\n  // Relative position = rotated local position (without body position offset)\\n  let relativePos = quatRotate(localPos, bodyQuaternion);\\n  \\n  particleRelativePos[particleIndex] = vec4<f32>(relativePos, f32(bodyId));\\n}\\n\"","export default \"// Derive particle velocities from body velocities\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleRelativePos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyVel: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> bodyAngularVel: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read_write> particleVel: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let relativePosAndBodyId = particleRelativePos[particleIndex];\\n  let relativePos = relativePosAndBodyId.xyz;\\n  let bodyId = u32(relativePosAndBodyId.w);\\n  \\n  let linearVel = bodyVel[bodyId].xyz;\\n  let angularVel = bodyAngularVel[bodyId].xyz;\\n  \\n  // v_particle = v_body + omega x r\\n  let vel = linearVel + cross3(angularVel, relativePos);\\n  \\n  particleVel[particleIndex] = vec4<f32>(vel, 1.0);\\n}\\n\"","export default \"// Clear the spatial hash grid\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read_write> gridCellCount: array<atomic<u32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let cellIndex = id.x;\\n  let gridRes = vec3<i32>(params.gridRes.xyz);\\n  let totalCells = u32(gridRes.x * gridRes.y * gridRes.z);\\n  \\n  if (cellIndex >= totalCells) {\\n    return;\\n  }\\n  \\n  atomicStore(&gridCellCount[cellIndex], 0u);\\n}\\n\"","export default \"// Build spatial hash grid from particle positions\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleWorldPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read_write> gridCellCount: array<atomic<u32>>;\\n@group(0) @binding(3) var<storage, read_write> gridCellParticles: array<u32>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let worldPos = particleWorldPos[particleIndex].xyz;\\n  let cellSize = vec3<f32>(params.radius * 2.0);\\n  let gridPos = params.gridPos.xyz;\\n  let gridRes = vec3<i32>(params.gridRes.xyz);\\n  let maxParticlesPerCell = u32(params.gridRes.w);\\n  \\n  // Get grid cell for this particle\\n  let cellPos = worldPosToGridPos(worldPos, gridPos, cellSize);\\n  \\n  // Check if within grid bounds\\n  if (!isValidGridPos(cellPos, gridRes)) {\\n    return;\\n  }\\n  \\n  let cellIndex = gridPosToIndex(cellPos, gridRes);\\n  \\n  // Atomically increment cell count and get slot\\n  let slot = atomicAdd(&gridCellCount[u32(cellIndex)], 1u);\\n  \\n  // Store particle index if slot available\\n  if (slot < maxParticlesPerCell) {\\n    let particleSlotIndex = u32(cellIndex) * maxParticlesPerCell + slot;\\n    gridCellParticles[particleSlotIndex] = particleIndex + 1u; // Store +1 so 0 means empty\\n  }\\n}\\n\"","export default \"// Calculate particle collision forces\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleWorldPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> particleRelativePos: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> particleVel: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read> bodyAngularVel: array<vec4<f32>>;\\n@group(0) @binding(5) var<storage, read> gridCellCount: array<u32>;\\n@group(0) @binding(6) var<storage, read> gridCellParticles: array<u32>;\\n@group(0) @binding(7) var<storage, read_write> particleForceOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let worldPosAndBodyId = particleWorldPos[particleIndex];\\n  let position = worldPosAndBodyId.xyz;\\n  let bodyId = u32(worldPosAndBodyId.w);\\n  \\n  let velocity = particleVel[particleIndex].xyz;\\n  let relativePos = particleRelativePos[particleIndex].xyz;\\n  let angularVel = bodyAngularVel[bodyId].xyz;\\n  \\n  let cellSize = vec3<f32>(params.radius * 2.0);\\n  let gridPos = params.gridPos.xyz;\\n  let gridRes = vec3<i32>(params.gridRes.xyz);\\n  let maxParticlesPerCell = u32(params.gridRes.w);\\n  let radius = params.radius;\\n  let stiffness = params.stiffness;\\n  let damping = params.damping;\\n  let friction = params.friction;\\n  \\n  var force = vec3<f32>(0.0);\\n  \\n  // Get current particle's grid cell\\n  let particleGridPos = worldPosToGridPos(position, gridPos, cellSize);\\n  \\n  // Check neighboring cells (3x3x3)\\n  for (var i = -1; i <= 1; i++) {\\n    for (var j = -1; j <= 1; j++) {\\n      for (var k = -1; k <= 1; k++) {\\n        let neighborCellPos = particleGridPos + vec3<i32>(i, j, k);\\n        \\n        if (!isValidGridPos(neighborCellPos, gridRes)) {\\n          continue;\\n        }\\n        \\n        let cellIndex = gridPosToIndex(neighborCellPos, gridRes);\\n        \\n        // Check all particles in this cell\\n        for (var slot = 0u; slot < maxParticlesPerCell; slot++) {\\n          let particleSlotIndex = u32(cellIndex) * maxParticlesPerCell + slot;\\n          let neighborIndexPlusOne = gridCellParticles[particleSlotIndex];\\n          \\n          if (neighborIndexPlusOne == 0u) {\\n            continue; // Empty slot\\n          }\\n          \\n          let neighborIndex = neighborIndexPlusOne - 1u;\\n          \\n          if (neighborIndex == particleIndex) {\\n            continue; // Skip self\\n          }\\n          \\n          let neighborPosAndBodyId = particleWorldPos[neighborIndex];\\n          let neighborPos = neighborPosAndBodyId.xyz;\\n          let neighborBodyId = u32(neighborPosAndBodyId.w);\\n          \\n          if (neighborBodyId == bodyId) {\\n            continue; // Skip same body\\n          }\\n          \\n          let neighborVel = particleVel[neighborIndex].xyz;\\n          let neighborRelativePos = particleRelativePos[neighborIndex].xyz;\\n          let neighborAngularVel = bodyAngularVel[neighborBodyId].xyz;\\n          \\n          // Check collision\\n          let r = position - neighborPos;\\n          let dist = length(r);\\n          \\n          if (dist > 0.0 && dist < radius * 2.0) {\\n            let dir = normalize(r);\\n            \\n            // Compute velocities including angular contribution\\n            let v = velocity - cross3(relativePos + radius * dir, angularVel);\\n            let nv = neighborVel - cross3(neighborRelativePos + radius * (-dir), neighborAngularVel);\\n            \\n            force += particleForce(stiffness, damping, friction, 2.0 * radius, radius, position, neighborPos, v, nv);\\n          }\\n        }\\n      }\\n    }\\n  }\\n  \\n  // Ground/boundary collisions\\n  let boxMin = vec3<f32>(-params.boxSize.x, 0.0, -params.boxSize.z);\\n  let boxMax = vec3<f32>(params.boxSize.x, params.boxSize.y * 0.5, params.boxSize.z);\\n  \\n  // X bounds\\n  {\\n    let dir = vec3<f32>(1.0, 0.0, 0.0);\\n    let v = velocity - cross3(relativePos + radius * dir, angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let x = position.x - radius;\\n    if (x < boxMin.x) {\\n      force += -(stiffness * (x - boxMin.x) * dir + damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  {\\n    let dir = vec3<f32>(-1.0, 0.0, 0.0);\\n    let v = velocity - cross3(relativePos + radius * (-dir), angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let x = position.x + radius;\\n    if (x > boxMax.x) {\\n      force -= -(stiffness * (x - boxMax.x) * dir - damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  \\n  // Y bounds (ground)\\n  {\\n    let dir = vec3<f32>(0.0, 1.0, 0.0);\\n    let v = velocity - cross3(relativePos + radius * dir, angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let y = position.y - radius;\\n    if (y < boxMin.y) {\\n      force += -(stiffness * (y - boxMin.y) * dir + damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  {\\n    let dir = vec3<f32>(0.0, -1.0, 0.0);\\n    let v = velocity - cross3(relativePos + radius * (-dir), angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let y = position.y + radius;\\n    if (y > boxMax.y) {\\n      force -= -(stiffness * (y - boxMax.y) * dir - damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  \\n  // Z bounds\\n  {\\n    let dir = vec3<f32>(0.0, 0.0, 1.0);\\n    let v = velocity - cross3(relativePos + radius * dir, angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let z = position.z - radius;\\n    if (z < boxMin.z) {\\n      force += -(stiffness * (z - boxMin.z) * dir + damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  {\\n    let dir = vec3<f32>(0.0, 0.0, -1.0);\\n    let v = velocity - cross3(relativePos + radius * (-dir), angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let z = position.z + radius;\\n    if (z > boxMax.z) {\\n      force -= -(stiffness * (z - boxMax.z) * dir - damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  \\n  // Interaction sphere collision\\n  let spherePos = params.sphere.xyz;\\n  let sphereRadius = params.sphere.w;\\n  let rSphere = position - spherePos;\\n  let distSphere = length(rSphere);\\n  if (distSphere > 0.0 && distSphere < sphereRadius + radius) {\\n    force += particleForce(stiffness, damping, friction, radius + sphereRadius, sphereRadius, position, spherePos, velocity, vec3<f32>(0.0));\\n  }\\n  \\n  particleForceOut[particleIndex] = vec4<f32>(force, 1.0);\\n}\\n\"","export default \"// Calculate particle collision torques (similar to force but for rotation)\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleWorldPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> particleRelativePos: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> particleVel: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read> bodyAngularVel: array<vec4<f32>>;\\n@group(0) @binding(5) var<storage, read> gridCellCount: array<u32>;\\n@group(0) @binding(6) var<storage, read> gridCellParticles: array<u32>;\\n@group(0) @binding(7) var<storage, read_write> particleTorqueOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let worldPosAndBodyId = particleWorldPos[particleIndex];\\n  let position = worldPosAndBodyId.xyz;\\n  let bodyId = u32(worldPosAndBodyId.w);\\n  \\n  let velocity = particleVel[particleIndex].xyz;\\n  let relativePos = particleRelativePos[particleIndex].xyz;\\n  let angularVel = bodyAngularVel[bodyId].xyz;\\n  \\n  let cellSize = vec3<f32>(params.radius * 2.0);\\n  let gridPos = params.gridPos.xyz;\\n  let gridRes = vec3<i32>(params.gridRes.xyz);\\n  let maxParticlesPerCell = u32(params.gridRes.w);\\n  let radius = params.radius;\\n  let stiffness = params.stiffness;\\n  let damping = params.damping;\\n  let friction = params.friction;\\n  \\n  var torque = vec3<f32>(0.0);\\n  \\n  // Get current particle's grid cell\\n  let particleGridPos = worldPosToGridPos(position, gridPos, cellSize);\\n  \\n  // Check neighboring cells (3x3x3) - same logic as update_force\\n  for (var i = -1; i <= 1; i++) {\\n    for (var j = -1; j <= 1; j++) {\\n      for (var k = -1; k <= 1; k++) {\\n        let neighborCellPos = particleGridPos + vec3<i32>(i, j, k);\\n        \\n        if (!isValidGridPos(neighborCellPos, gridRes)) {\\n          continue;\\n        }\\n        \\n        let cellIndex = gridPosToIndex(neighborCellPos, gridRes);\\n        \\n        for (var slot = 0u; slot < maxParticlesPerCell; slot++) {\\n          let particleSlotIndex = u32(cellIndex) * maxParticlesPerCell + slot;\\n          let neighborIndexPlusOne = gridCellParticles[particleSlotIndex];\\n          \\n          if (neighborIndexPlusOne == 0u) {\\n            continue;\\n          }\\n          \\n          let neighborIndex = neighborIndexPlusOne - 1u;\\n          \\n          if (neighborIndex == particleIndex) {\\n            continue;\\n          }\\n          \\n          let neighborPosAndBodyId = particleWorldPos[neighborIndex];\\n          let neighborPos = neighborPosAndBodyId.xyz;\\n          let neighborBodyId = u32(neighborPosAndBodyId.w);\\n          \\n          if (neighborBodyId == bodyId) {\\n            continue;\\n          }\\n          \\n          let neighborVel = particleVel[neighborIndex].xyz;\\n          let neighborRelativePos = particleRelativePos[neighborIndex].xyz;\\n          let neighborAngularVel = bodyAngularVel[neighborBodyId].xyz;\\n          \\n          let r = position - neighborPos;\\n          let dist = length(r);\\n          \\n          if (dist > 0.0 && dist < radius * 2.0) {\\n            let dir = normalize(r);\\n            let v = velocity - cross3(relativePos + radius * dir, angularVel);\\n            let nv = neighborVel - cross3(neighborRelativePos + radius * (-dir), neighborAngularVel);\\n            \\n            let force = particleForce(stiffness, damping, friction, 2.0 * radius, radius, position, neighborPos, v, nv);\\n            \\n            // Torque = r x F (relative position cross force)\\n            torque += cross3(relativePos, force);\\n          }\\n        }\\n      }\\n    }\\n  }\\n  \\n  particleTorqueOut[particleIndex] = vec4<f32>(torque, 1.0);\\n}\\n\"","export default \"// Reduce particle forces to body forces using atomics\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleLocalPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> particleForceBuf: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read_write> bodyForce: array<atomic<u32>>;\\n\\n// Helper to atomic add f32 by encoding as u32\\nfn atomicAddF32(ptr: ptr<storage, atomic<u32>, read_write>, value: f32) {\\n  var old = atomicLoad(ptr);\\n  loop {\\n    let newVal = bitcast<u32>(bitcast<f32>(old) + value);\\n    let result = atomicCompareExchangeWeak(ptr, old, newVal);\\n    if (result.exchanged) {\\n      break;\\n    }\\n    old = result.old_value;\\n  }\\n}\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let localPosAndBodyId = particleLocalPos[particleIndex];\\n  let bodyId = u32(localPosAndBodyId.w);\\n  \\n  let force = particleForceBuf[particleIndex].xyz;\\n  \\n  // Atomic add force components to body\\n  // Body force is stored as 4 u32s: (fx, fy, fz, 1) encoded as f32->u32\\n  let bodyOffset = bodyId * 4u;\\n  \\n  atomicAddF32(&bodyForce[bodyOffset + 0u], force.x);\\n  atomicAddF32(&bodyForce[bodyOffset + 1u], force.y);\\n  atomicAddF32(&bodyForce[bodyOffset + 2u], force.z);\\n}\\n\"","export default \"// Reduce particle torques to body torques using atomics\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleLocalPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> particleRelativePos: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> particleForceBuf: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read> particleTorque: array<vec4<f32>>;\\n@group(0) @binding(5) var<storage, read_write> bodyTorque: array<atomic<u32>>;\\n\\n// Helper to atomic add f32 by encoding as u32\\nfn atomicAddF32Torque(ptr: ptr<storage, atomic<u32>, read_write>, value: f32) {\\n  var old = atomicLoad(ptr);\\n  loop {\\n    let newVal = bitcast<u32>(bitcast<f32>(old) + value);\\n    let result = atomicCompareExchangeWeak(ptr, old, newVal);\\n    if (result.exchanged) {\\n      break;\\n    }\\n    old = result.old_value;\\n  }\\n}\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let localPosAndBodyId = particleLocalPos[particleIndex];\\n  let bodyId = u32(localPosAndBodyId.w);\\n  \\n  let relativePos = particleRelativePos[particleIndex].xyz;\\n  let force = particleForceBuf[particleIndex].xyz;\\n  let torqueFromCollision = particleTorque[particleIndex].xyz;\\n  \\n  // Total torque = collision torque + r x F\\n  let totalTorque = torqueFromCollision + cross3(relativePos, force);\\n  \\n  // Atomic add torque components to body\\n  let bodyOffset = bodyId * 4u;\\n  \\n  atomicAddF32Torque(&bodyTorque[bodyOffset + 0u], totalTorque.x);\\n  atomicAddF32Torque(&bodyTorque[bodyOffset + 1u], totalTorque.y);\\n  atomicAddF32Torque(&bodyTorque[bodyOffset + 2u], totalTorque.z);\\n}\\n\"","export default \"// Update body linear velocity\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> bodyVelIn: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyForce: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> bodyMass: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read_write> bodyVelOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let bodyIndex = id.x;\\n  \\n  if (bodyIndex >= u32(params.bodyCount)) {\\n    return;\\n  }\\n  \\n  let velocity = bodyVelIn[bodyIndex].xyz;\\n  let force = bodyForce[bodyIndex].xyz;\\n  let massData = bodyMass[bodyIndex];\\n  let invMass = massData.w; // Inverse mass stored in w component\\n  \\n  let dt = params.dt;\\n  let gravity = params.gravity.xyz;\\n  let drag = params.drag;\\n  let maxVel = params.maxVelocity.xyz;\\n  \\n  // Skip static bodies (invMass == 0)\\n  if (invMass == 0.0) {\\n    bodyVelOut[bodyIndex] = vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n    return;\\n  }\\n  \\n  // Apply gravity and forces: v += (g + F/m) * dt\\n  var newVel = velocity + (gravity + force * invMass) * dt;\\n  \\n  // Apply drag\\n  newVel = newVel * (1.0 - drag * dt);\\n  \\n  // Clamp velocity\\n  newVel = clamp(newVel, -maxVel, maxVel);\\n  \\n  bodyVelOut[bodyIndex] = vec4<f32>(newVel, 1.0);\\n}\\n\"","export default \"// Update body angular velocity\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> bodyAngVelIn: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyTorque: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> bodyMass: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read> bodyQuat: array<vec4<f32>>;\\n@group(0) @binding(5) var<storage, read_write> bodyAngVelOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let bodyIndex = id.x;\\n  \\n  if (bodyIndex >= u32(params.bodyCount)) {\\n    return;\\n  }\\n  \\n  let angularVel = bodyAngVelIn[bodyIndex].xyz;\\n  let torque = bodyTorque[bodyIndex].xyz;\\n  let massData = bodyMass[bodyIndex];\\n  let invInertia = massData.xyz; // Inverse inertia stored in xyz\\n  let invMass = massData.w;\\n  let quat = bodyQuat[bodyIndex];\\n  \\n  let dt = params.dt;\\n  let drag = params.drag;\\n  let maxVel = params.maxVelocity.xyz;\\n  \\n  // Skip static bodies\\n  if (invMass == 0.0) {\\n    bodyAngVelOut[bodyIndex] = vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n    return;\\n  }\\n  \\n  // Compute world-space inverse inertia tensor\\n  let invIWorld = invInertiaWorld(quat, invInertia);\\n  \\n  // Apply torque: omega += I^-1 * T * dt\\n  let angularAccel = invIWorld * torque;\\n  var newAngVel = angularVel + angularAccel * dt;\\n  \\n  // Apply drag\\n  newAngVel = newAngVel * (1.0 - drag * dt);\\n  \\n  // Clamp angular velocity\\n  newAngVel = clamp(newAngVel, -maxVel, maxVel);\\n  \\n  bodyAngVelOut[bodyIndex] = vec4<f32>(newAngVel, 1.0);\\n}\\n\"","export default \"// Update body position\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> bodyPosIn: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyVel: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read_write> bodyPosOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let bodyIndex = id.x;\\n  \\n  if (bodyIndex >= u32(params.bodyCount)) {\\n    return;\\n  }\\n  \\n  let position = bodyPosIn[bodyIndex].xyz;\\n  let velocity = bodyVel[bodyIndex].xyz;\\n  let dt = params.dt;\\n  \\n  // Simple Euler integration: x += v * dt\\n  let newPos = position + velocity * dt;\\n  \\n  bodyPosOut[bodyIndex] = vec4<f32>(newPos, 1.0);\\n}\\n\"","export default \"// Update body quaternion\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> bodyQuatIn: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyAngVel: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read_write> bodyQuatOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let bodyIndex = id.x;\\n  \\n  if (bodyIndex >= u32(params.bodyCount)) {\\n    return;\\n  }\\n  \\n  let quat = bodyQuatIn[bodyIndex];\\n  let angularVel = bodyAngVel[bodyIndex].xyz;\\n  let dt = params.dt;\\n  \\n  // Integrate quaternion with angular velocity\\n  let newQuat = quatIntegrate(quat, angularVel, dt);\\n  \\n  bodyQuatOut[bodyIndex] = newQuat;\\n}\\n\"","/**\n * World - Main physics simulation class\n * Orchestrates the GPU-based physics simulation\n */\n\nimport { Vec3, Quat, calculateBoxInertia } from './math';\nimport { \n  initWebGPU, \n  createShaderModule, \n  createStorageBuffer,\n  createUniformBuffer,\n  createStagingBuffer,\n  writeBuffer,\n  readBuffer,\n  getDispatchSize,\n  alignTo,\n  type WebGPUContext \n} from './device';\nimport type { PhysicsBuffers, PhysicsPipelines, SimulationParams, GridConfig } from './types';\n\n// Import shaders as raw WGSL strings\nimport sharedWgsl from './shaders/shared.wgsl?raw';\nimport localToWorldWgsl from './shaders/local_to_world.wgsl?raw';\nimport localToRelativeWgsl from './shaders/local_to_relative.wgsl?raw';\nimport bodyVelToParticleVelWgsl from './shaders/body_vel_to_particle_vel.wgsl?raw';\nimport clearGridWgsl from './shaders/clear_grid.wgsl?raw';\nimport buildGridWgsl from './shaders/build_grid.wgsl?raw';\nimport updateForceWgsl from './shaders/update_force.wgsl?raw';\nimport updateTorqueWgsl from './shaders/update_torque.wgsl?raw';\nimport reduceForceWgsl from './shaders/reduce_force.wgsl?raw';\nimport reduceTorqueWgsl from './shaders/reduce_torque.wgsl?raw';\nimport updateBodyVelocityWgsl from './shaders/update_body_velocity.wgsl?raw';\nimport updateBodyAngularVelocityWgsl from './shaders/update_body_angular_velocity.wgsl?raw';\nimport updateBodyPositionWgsl from './shaders/update_body_position.wgsl?raw';\nimport updateBodyQuaternionWgsl from './shaders/update_body_quaternion.wgsl?raw';\n\n/**\n * Configuration options for creating a World\n */\nexport interface WorldOptions {\n  /** Maximum number of rigid bodies */\n  maxBodies?: number;\n  /** Maximum number of collision particles */\n  maxParticles?: number;\n  /** Gravity vector (default: [0, -9.81, 0]) */\n  gravity?: Vec3;\n  /** Spring stiffness for contacts */\n  stiffness?: number;\n  /** Damping coefficient */\n  damping?: number;\n  /** Friction coefficient */\n  friction?: number;\n  /** Air drag coefficient */\n  drag?: number;\n  /** Particle/cell radius */\n  radius?: number;\n  /** Fixed timestep for simulation */\n  fixedTimeStep?: number;\n  /** World bounds (half extents) */\n  boxSize?: Vec3;\n  /** Broadphase grid position */\n  gridPosition?: Vec3;\n  /** Broadphase grid resolution */\n  gridResolution?: Vec3;\n  /** Maximum substeps per frame */\n  maxSubSteps?: number;\n}\n\n// Constants\nconst WORKGROUP_SIZE = 64;\nconst MAX_PARTICLES_PER_CELL = 4;\n\n/**\n * Physics World - manages GPU-based rigid body simulation\n */\nexport class World {\n  // WebGPU context\n  private ctx!: WebGPUContext;\n  private device!: GPUDevice;\n  \n  // Buffers\n  private buffers!: PhysicsBuffers;\n  private pipelines!: PhysicsPipelines;\n  private layouts!: Record<string, GPUBindGroupLayout>;\n  private bindGroups: Map<string, GPUBindGroup> = new Map();\n  \n  // Simulation state\n  private _bodyCount = 0;\n  private _particleCount = 0;\n  private readonly maxBodies: number;\n  private readonly maxParticles: number;\n  \n  // Simulation parameters\n  private params: SimulationParams;\n  private grid: GridConfig;\n  \n  // Timing\n  private time = 0;\n  private fixedTime = 0;\n  private accumulator = 0;\n  private maxSubSteps: number;\n  private _interpolationValue = 0;\n  \n  // Double-buffer state (which buffer is current)\n  private bufferIndex = 0;\n  \n  // CPU-side data for initialization\n  private bodyPositions: Float32Array;\n  private bodyQuaternions: Float32Array;\n  private bodyMasses: Float32Array;\n  private particleLocalPositions: Float32Array;\n  \n  // Dirty flags for CPU->GPU sync\n  private bodyDataDirty = true;\n  private particleDataDirty = true;\n  private massDirty = true;\n  \n  // Sphere interaction\n  private interactionSphere = { \n    position: new Vec3(10, 1, 0), \n    radius: 1 \n  };\n  \n  // Initialization promise\n  private initPromise: Promise<void>;\n  private initialized = false;\n\n  constructor(options: WorldOptions = {}) {\n    this.maxBodies = options.maxBodies || 64;\n    this.maxParticles = options.maxParticles || 256;\n    this.maxSubSteps = options.maxSubSteps || 5;\n    \n    // Initialize simulation parameters\n    this.params = {\n      stiffness: options.stiffness ?? 1700,\n      damping: options.damping ?? 6,\n      friction: options.friction ?? 2,\n      drag: options.drag ?? 0.1,\n      radius: options.radius ?? 0.5,\n      fixedTimeStep: options.fixedTimeStep ?? 1/120,\n      gravity: options.gravity?.data ?? new Float32Array([0, -9.81, 0]),\n      boxSize: options.boxSize?.data ?? new Float32Array([10, 10, 10])\n    };\n    \n    // Initialize grid configuration\n    const gridRes = options.gridResolution || new Vec3(64, 64, 64);\n    this.grid = {\n      position: options.gridPosition?.data ?? new Float32Array([0, 0, 0]),\n      resolution: gridRes.data,\n      maxParticlesPerCell: MAX_PARTICLES_PER_CELL\n    };\n    \n    // Allocate CPU-side arrays\n    this.bodyPositions = new Float32Array(this.maxBodies * 4);\n    this.bodyQuaternions = new Float32Array(this.maxBodies * 4);\n    this.bodyMasses = new Float32Array(this.maxBodies * 4);\n    this.particleLocalPositions = new Float32Array(this.maxParticles * 4);\n    \n    // Initialize quaternions to identity\n    for (let i = 0; i < this.maxBodies; i++) {\n      this.bodyQuaternions[i * 4 + 3] = 1; // w = 1\n    }\n    \n    // Start async initialization\n    this.initPromise = this.initialize();\n  }\n\n  /**\n   * Initialize WebGPU resources\n   */\n  private async initialize(): Promise<void> {\n    // Get WebGPU context\n    this.ctx = await initWebGPU();\n    this.device = this.ctx.device;\n    \n    // Create buffers\n    this.createBuffers();\n    \n    // Create pipelines\n    await this.createPipelines();\n    \n    // Create bind groups\n    this.createBindGroups();\n    \n    this.initialized = true;\n  }\n\n  /**\n   * Wait for initialization to complete\n   */\n  async ready(): Promise<void> {\n    await this.initPromise;\n  }\n\n  /**\n   * Create all GPU buffers\n   */\n  private createBuffers(): void {\n    const device = this.device;\n    const bodySize = this.maxBodies * 4 * 4; // vec4<f32> per body\n    const particleSize = this.maxParticles * 4 * 4;\n    const gridCellCount = Math.ceil(this.grid.resolution[0]) * \n                          Math.ceil(this.grid.resolution[1]) * \n                          Math.ceil(this.grid.resolution[2]);\n    const gridSize = gridCellCount * 4; // u32 count per cell\n    const gridParticlesSize = gridCellCount * MAX_PARTICLES_PER_CELL * 4; // u32 indices\n\n    this.buffers = {\n      // Body buffers (double-buffered)\n      bodyPositionA: createStorageBuffer(device, bodySize, 'body-position-a'),\n      bodyPositionB: createStorageBuffer(device, bodySize, 'body-position-b'),\n      bodyQuaternionA: createStorageBuffer(device, bodySize, 'body-quaternion-a'),\n      bodyQuaternionB: createStorageBuffer(device, bodySize, 'body-quaternion-b'),\n      bodyVelocityA: createStorageBuffer(device, bodySize, 'body-velocity-a'),\n      bodyVelocityB: createStorageBuffer(device, bodySize, 'body-velocity-b'),\n      bodyAngularVelocityA: createStorageBuffer(device, bodySize, 'body-angular-velocity-a'),\n      bodyAngularVelocityB: createStorageBuffer(device, bodySize, 'body-angular-velocity-b'),\n      bodyForce: createStorageBuffer(device, bodySize, 'body-force'),\n      bodyTorque: createStorageBuffer(device, bodySize, 'body-torque'),\n      bodyMass: createStorageBuffer(device, bodySize, 'body-mass'),\n\n      // Particle buffers\n      particleLocalPosition: createStorageBuffer(device, particleSize, 'particle-local-position'),\n      particleRelativePosition: createStorageBuffer(device, particleSize, 'particle-relative-position'),\n      particleWorldPosition: createStorageBuffer(device, particleSize, 'particle-world-position'),\n      particleVelocity: createStorageBuffer(device, particleSize, 'particle-velocity'),\n      particleForce: createStorageBuffer(device, particleSize, 'particle-force'),\n      particleTorque: createStorageBuffer(device, particleSize, 'particle-torque'),\n\n      // Broadphase grid\n      gridCellCount: createStorageBuffer(device, gridSize, 'grid-cell-count'),\n      gridCellParticles: createStorageBuffer(device, gridParticlesSize, 'grid-cell-particles'),\n\n      // Uniform params buffer (aligned to 256 bytes for uniform binding)\n      params: createUniformBuffer(device, alignTo(256, 256), 'params'),\n\n      // Staging buffers for CPU readback\n      stagingPosition: createStagingBuffer(device, bodySize, 'staging-position'),\n      stagingQuaternion: createStagingBuffer(device, bodySize, 'staging-quaternion'),\n    };\n  }\n\n  /**\n   * Create compute pipelines\n   */\n  private async createPipelines(): Promise<void> {\n    const device = this.device;\n    \n    // Combine shared code with each shader\n    const makeShader = (code: string) => sharedWgsl + '\\n' + code;\n    const bufferLayout = (binding: number, type: GPUBufferBindingType): GPUBindGroupLayoutEntry => ({\n      binding,\n      visibility: GPUShaderStage.COMPUTE,\n      buffer: { type }\n    });\n    const makeLayout = (label: string, entries: GPUBindGroupLayoutEntry[]) =>\n      device.createBindGroupLayout({ label, entries });\n    const makePipeline = (\n      label: string,\n      module: GPUShaderModule,\n      layout: GPUBindGroupLayout\n    ) => device.createComputePipeline({\n      label,\n      layout: device.createPipelineLayout({\n        label: `${label}-layout`,\n        bindGroupLayouts: [layout]\n      }),\n      compute: {\n        module,\n        entryPoint: 'main'\n      }\n    });\n    \n    // Create shader modules\n    const modules = {\n      localToWorld: createShaderModule(device, makeShader(localToWorldWgsl), 'local-to-world'),\n      localToRelative: createShaderModule(device, makeShader(localToRelativeWgsl), 'local-to-relative'),\n      bodyVelToParticleVel: createShaderModule(device, makeShader(bodyVelToParticleVelWgsl), 'body-vel-to-particle-vel'),\n      clearGrid: createShaderModule(device, makeShader(clearGridWgsl), 'clear-grid'),\n      buildGrid: createShaderModule(device, makeShader(buildGridWgsl), 'build-grid'),\n      updateForce: createShaderModule(device, makeShader(updateForceWgsl), 'update-force'),\n      updateTorque: createShaderModule(device, makeShader(updateTorqueWgsl), 'update-torque'),\n      reduceForce: createShaderModule(device, makeShader(reduceForceWgsl), 'reduce-force'),\n      reduceTorque: createShaderModule(device, makeShader(reduceTorqueWgsl), 'reduce-torque'),\n      updateBodyVelocity: createShaderModule(device, makeShader(updateBodyVelocityWgsl), 'update-body-velocity'),\n      updateBodyAngularVelocity: createShaderModule(device, makeShader(updateBodyAngularVelocityWgsl), 'update-body-angular-velocity'),\n      updateBodyPosition: createShaderModule(device, makeShader(updateBodyPositionWgsl), 'update-body-position'),\n      updateBodyQuaternion: createShaderModule(device, makeShader(updateBodyQuaternionWgsl), 'update-body-quaternion'),\n    };\n\n    // Explicit bind group layouts (avoids auto layout mismatch issues)\n    const layouts = {\n      localToWorld: makeLayout('layout/local-to-world', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'read-only-storage'),\n        bufferLayout(3, 'read-only-storage'),\n        bufferLayout(4, 'storage'),\n      ]),\n      localToRelative: makeLayout('layout/local-to-relative', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'read-only-storage'),\n        bufferLayout(3, 'read-only-storage'),\n        bufferLayout(4, 'storage'),\n      ]),\n      bodyVelToParticleVel: makeLayout('layout/body-vel-to-particle-vel', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'read-only-storage'),\n        bufferLayout(3, 'read-only-storage'),\n        bufferLayout(4, 'storage'),\n      ]),\n      clearGrid: makeLayout('layout/clear-grid', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'storage'),\n      ]),\n      buildGrid: makeLayout('layout/build-grid', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'storage'),\n        bufferLayout(3, 'storage'),\n      ]),\n      updateForce: makeLayout('layout/update-force', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'read-only-storage'),\n        bufferLayout(3, 'read-only-storage'),\n        bufferLayout(4, 'read-only-storage'),\n        bufferLayout(5, 'read-only-storage'),\n        bufferLayout(6, 'read-only-storage'),\n        bufferLayout(7, 'storage'),\n      ]),\n      updateTorque: makeLayout('layout/update-torque', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'read-only-storage'),\n        bufferLayout(3, 'read-only-storage'),\n        bufferLayout(4, 'read-only-storage'),\n        bufferLayout(5, 'read-only-storage'),\n        bufferLayout(6, 'read-only-storage'),\n        bufferLayout(7, 'storage'),\n      ]),\n      reduceForce: makeLayout('layout/reduce-force', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'read-only-storage'),\n        bufferLayout(3, 'storage'),\n      ]),\n      reduceTorque: makeLayout('layout/reduce-torque', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'read-only-storage'),\n        bufferLayout(3, 'read-only-storage'),\n        bufferLayout(4, 'read-only-storage'),\n        bufferLayout(5, 'storage'),\n      ]),\n      updateBodyVelocity: makeLayout('layout/update-body-velocity', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'read-only-storage'),\n        bufferLayout(3, 'read-only-storage'),\n        bufferLayout(4, 'storage'),\n      ]),\n      updateBodyAngularVelocity: makeLayout('layout/update-body-angular-velocity', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'read-only-storage'),\n        bufferLayout(3, 'read-only-storage'),\n        bufferLayout(4, 'read-only-storage'),\n        bufferLayout(5, 'storage'),\n      ]),\n      updateBodyPosition: makeLayout('layout/update-body-position', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'read-only-storage'),\n        bufferLayout(3, 'storage'),\n      ]),\n      updateBodyQuaternion: makeLayout('layout/update-body-quaternion', [\n        bufferLayout(0, 'uniform'),\n        bufferLayout(1, 'read-only-storage'),\n        bufferLayout(2, 'read-only-storage'),\n        bufferLayout(3, 'storage'),\n      ]),\n    };\n\n    this.layouts = layouts;\n\n    // Create pipelines with explicit layouts\n    this.pipelines = {\n      localToWorld: makePipeline('local-to-world', modules.localToWorld, layouts.localToWorld),\n      localToRelative: makePipeline('local-to-relative', modules.localToRelative, layouts.localToRelative),\n      bodyVelToParticleVel: makePipeline('body-vel-to-particle-vel', modules.bodyVelToParticleVel, layouts.bodyVelToParticleVel),\n      clearGrid: makePipeline('clear-grid', modules.clearGrid, layouts.clearGrid),\n      buildGrid: makePipeline('build-grid', modules.buildGrid, layouts.buildGrid),\n      updateForce: makePipeline('update-force', modules.updateForce, layouts.updateForce),\n      updateTorque: makePipeline('update-torque', modules.updateTorque, layouts.updateTorque),\n      reduceForce: makePipeline('reduce-force', modules.reduceForce, layouts.reduceForce),\n      reduceTorque: makePipeline('reduce-torque', modules.reduceTorque, layouts.reduceTorque),\n      updateBodyVelocity: makePipeline('update-body-velocity', modules.updateBodyVelocity, layouts.updateBodyVelocity),\n      updateBodyAngularVelocity: makePipeline('update-body-angular-velocity', modules.updateBodyAngularVelocity, layouts.updateBodyAngularVelocity),\n      updateBodyPosition: makePipeline('update-body-position', modules.updateBodyPosition, layouts.updateBodyPosition),\n      updateBodyQuaternion: makePipeline('update-body-quaternion', modules.updateBodyQuaternion, layouts.updateBodyQuaternion),\n    };\n  }\n\n  /**\n   * Create bind groups for each pipeline\n   */\n  private createBindGroups(): void {\n    // Bind groups will be created dynamically based on buffer swapping\n    // This is called to set up the initial state\n    this.updateBindGroups();\n  }\n\n  /**\n   * Update bind groups after buffer swap\n   */\n  private updateBindGroups(): void {\n    const device = this.device;\n    const buffers = this.buffers;\n    const layouts = this.layouts;\n    \n    // Get current read/write buffers based on buffer index\n    const posRead = this.bufferIndex === 0 ? buffers.bodyPositionA : buffers.bodyPositionB;\n    const posWrite = this.bufferIndex === 0 ? buffers.bodyPositionB : buffers.bodyPositionA;\n    const quatRead = this.bufferIndex === 0 ? buffers.bodyQuaternionA : buffers.bodyQuaternionB;\n    const quatWrite = this.bufferIndex === 0 ? buffers.bodyQuaternionB : buffers.bodyQuaternionA;\n    const velRead = this.bufferIndex === 0 ? buffers.bodyVelocityA : buffers.bodyVelocityB;\n    const velWrite = this.bufferIndex === 0 ? buffers.bodyVelocityB : buffers.bodyVelocityA;\n    const angVelRead = this.bufferIndex === 0 ? buffers.bodyAngularVelocityA : buffers.bodyAngularVelocityB;\n    const angVelWrite = this.bufferIndex === 0 ? buffers.bodyAngularVelocityB : buffers.bodyAngularVelocityA;\n\n    // localToWorld bind group\n    this.bindGroups.set('localToWorld', device.createBindGroup({\n      layout: layouts.localToWorld,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleLocalPosition } },\n        { binding: 2, resource: { buffer: posRead } },\n        { binding: 3, resource: { buffer: quatRead } },\n        { binding: 4, resource: { buffer: buffers.particleWorldPosition } },\n      ]\n    }));\n\n    // localToRelative bind group\n    this.bindGroups.set('localToRelative', device.createBindGroup({\n      layout: layouts.localToRelative,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleLocalPosition } },\n        { binding: 2, resource: { buffer: posRead } },\n        { binding: 3, resource: { buffer: quatRead } },\n        { binding: 4, resource: { buffer: buffers.particleRelativePosition } },\n      ]\n    }));\n\n    // bodyVelToParticleVel bind group\n    this.bindGroups.set('bodyVelToParticleVel', device.createBindGroup({\n      layout: layouts.bodyVelToParticleVel,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleRelativePosition } },\n        { binding: 2, resource: { buffer: velRead } },\n        { binding: 3, resource: { buffer: angVelRead } },\n        { binding: 4, resource: { buffer: buffers.particleVelocity } },\n      ]\n    }));\n\n    // clearGrid bind group\n    this.bindGroups.set('clearGrid', device.createBindGroup({\n      layout: layouts.clearGrid,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.gridCellCount } },\n      ]\n    }));\n\n    // buildGrid bind group\n    this.bindGroups.set('buildGrid', device.createBindGroup({\n      layout: layouts.buildGrid,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleWorldPosition } },\n        { binding: 2, resource: { buffer: buffers.gridCellCount } },\n        { binding: 3, resource: { buffer: buffers.gridCellParticles } },\n      ]\n    }));\n\n    // updateForce bind group\n    this.bindGroups.set('updateForce', device.createBindGroup({\n      layout: layouts.updateForce,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleWorldPosition } },\n        { binding: 2, resource: { buffer: buffers.particleRelativePosition } },\n        { binding: 3, resource: { buffer: buffers.particleVelocity } },\n        { binding: 4, resource: { buffer: angVelRead } },\n        { binding: 5, resource: { buffer: buffers.gridCellCount } },\n        { binding: 6, resource: { buffer: buffers.gridCellParticles } },\n        { binding: 7, resource: { buffer: buffers.particleForce } },\n      ]\n    }));\n\n    // updateTorque bind group\n    this.bindGroups.set('updateTorque', device.createBindGroup({\n      layout: layouts.updateTorque,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleWorldPosition } },\n        { binding: 2, resource: { buffer: buffers.particleRelativePosition } },\n        { binding: 3, resource: { buffer: buffers.particleVelocity } },\n        { binding: 4, resource: { buffer: angVelRead } },\n        { binding: 5, resource: { buffer: buffers.gridCellCount } },\n        { binding: 6, resource: { buffer: buffers.gridCellParticles } },\n        { binding: 7, resource: { buffer: buffers.particleTorque } },\n      ]\n    }));\n\n    // reduceForce bind group\n    this.bindGroups.set('reduceForce', device.createBindGroup({\n      layout: layouts.reduceForce,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleLocalPosition } },\n        { binding: 2, resource: { buffer: buffers.particleForce } },\n        { binding: 3, resource: { buffer: buffers.bodyForce } },\n      ]\n    }));\n\n    // reduceTorque bind group\n    this.bindGroups.set('reduceTorque', device.createBindGroup({\n      layout: layouts.reduceTorque,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleLocalPosition } },\n        { binding: 2, resource: { buffer: buffers.particleRelativePosition } },\n        { binding: 3, resource: { buffer: buffers.particleForce } },\n        { binding: 4, resource: { buffer: buffers.particleTorque } },\n        { binding: 5, resource: { buffer: buffers.bodyTorque } },\n      ]\n    }));\n\n    // updateBodyVelocity bind group\n    this.bindGroups.set('updateBodyVelocity', device.createBindGroup({\n      layout: layouts.updateBodyVelocity,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: velRead } },\n        { binding: 2, resource: { buffer: buffers.bodyForce } },\n        { binding: 3, resource: { buffer: buffers.bodyMass } },\n        { binding: 4, resource: { buffer: velWrite } },\n      ]\n    }));\n\n    // updateBodyAngularVelocity bind group\n    this.bindGroups.set('updateBodyAngularVelocity', device.createBindGroup({\n      layout: layouts.updateBodyAngularVelocity,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: angVelRead } },\n        { binding: 2, resource: { buffer: buffers.bodyTorque } },\n        { binding: 3, resource: { buffer: buffers.bodyMass } },\n        { binding: 4, resource: { buffer: quatRead } },\n        { binding: 5, resource: { buffer: angVelWrite } },\n      ]\n    }));\n\n    // updateBodyPosition bind group\n    this.bindGroups.set('updateBodyPosition', device.createBindGroup({\n      layout: layouts.updateBodyPosition,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: posRead } },\n        { binding: 2, resource: { buffer: velWrite } }, // Use updated velocity\n        { binding: 3, resource: { buffer: posWrite } },\n      ]\n    }));\n\n    // updateBodyQuaternion bind group\n    this.bindGroups.set('updateBodyQuaternion', device.createBindGroup({\n      layout: layouts.updateBodyQuaternion,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: quatRead } },\n        { binding: 2, resource: { buffer: angVelWrite } }, // Use updated angular velocity\n        { binding: 3, resource: { buffer: quatWrite } },\n      ]\n    }));\n  }\n\n  /**\n   * Swap double-buffered resources\n   */\n  private swapBuffers(): void {\n    this.bufferIndex = 1 - this.bufferIndex;\n    this.updateBindGroups();\n  }\n\n  /**\n   * Sync CPU data to GPU\n   */\n  private flushData(): void {\n    if (this.bodyDataDirty) {\n      writeBuffer(this.device, this.buffers.bodyPositionA, this.bodyPositions);\n      writeBuffer(this.device, this.buffers.bodyPositionB, this.bodyPositions);\n      writeBuffer(this.device, this.buffers.bodyQuaternionA, this.bodyQuaternions);\n      writeBuffer(this.device, this.buffers.bodyQuaternionB, this.bodyQuaternions);\n      this.bodyDataDirty = false;\n    }\n\n    if (this.particleDataDirty) {\n      writeBuffer(this.device, this.buffers.particleLocalPosition, this.particleLocalPositions);\n      this.particleDataDirty = false;\n    }\n\n    if (this.massDirty) {\n      writeBuffer(this.device, this.buffers.bodyMass, this.bodyMasses);\n      this.massDirty = false;\n    }\n\n    // Update params uniform\n    this.updateParamsBuffer();\n  }\n\n  /**\n   * Update the params uniform buffer\n   */\n  private updateParamsBuffer(): void {\n    // Pack parameters into buffer\n    // Layout: vec4 params1 (stiffness, damping, radius, particleCount)\n    //         vec4 params2 (dt, friction, drag, bodyCount)\n    //         vec4 gravity (x, y, z, 0)\n    //         vec4 boxSize (x, y, z, 0)\n    //         vec4 gridPos (x, y, z, 0)\n    //         vec4 gridRes (x, y, z, maxParticlesPerCell)\n    //         vec4 sphereInteraction (x, y, z, radius)\n    //         vec4 maxVelocity (x, y, z, 0)\n    const data = new Float32Array(32);\n    \n    data[0] = this.params.stiffness;\n    data[1] = this.params.damping;\n    data[2] = this.params.radius;\n    data[3] = this._particleCount;\n    \n    data[4] = this.params.fixedTimeStep;\n    data[5] = this.params.friction;\n    data[6] = this.params.drag;\n    data[7] = this._bodyCount;\n    \n    data[8] = this.params.gravity[0];\n    data[9] = this.params.gravity[1];\n    data[10] = this.params.gravity[2];\n    data[11] = 0;\n    \n    data[12] = this.params.boxSize[0];\n    data[13] = this.params.boxSize[1];\n    data[14] = this.params.boxSize[2];\n    data[15] = 0;\n    \n    data[16] = this.grid.position[0];\n    data[17] = this.grid.position[1];\n    data[18] = this.grid.position[2];\n    data[19] = 0;\n    \n    data[20] = this.grid.resolution[0];\n    data[21] = this.grid.resolution[1];\n    data[22] = this.grid.resolution[2];\n    data[23] = this.grid.maxParticlesPerCell;\n    \n    data[24] = this.interactionSphere.position.x;\n    data[25] = this.interactionSphere.position.y;\n    data[26] = this.interactionSphere.position.z;\n    data[27] = this.interactionSphere.radius;\n    \n    // Max velocity based on radius and timestep\n    const maxV = 2 * this.params.radius / this.params.fixedTimeStep;\n    data[28] = maxV;\n    data[29] = maxV;\n    data[30] = maxV;\n    data[31] = 0;\n    \n    writeBuffer(this.device, this.buffers.params, data);\n  }\n\n  /**\n   * Add a rigid body to the simulation\n   */\n  addBody(\n    x: number, y: number, z: number,\n    qx: number, qy: number, qz: number, qw: number,\n    mass: number,\n    inertiaX: number, inertiaY: number, inertiaZ: number\n  ): number {\n    if (this._bodyCount >= this.maxBodies) {\n      console.warn(`Cannot add body: maximum (${this.maxBodies}) reached`);\n      return -1;\n    }\n\n    const id = this._bodyCount;\n    const offset = id * 4;\n\n    // Position\n    this.bodyPositions[offset] = x;\n    this.bodyPositions[offset + 1] = y;\n    this.bodyPositions[offset + 2] = z;\n    this.bodyPositions[offset + 3] = 1;\n\n    // Quaternion\n    this.bodyQuaternions[offset] = qx;\n    this.bodyQuaternions[offset + 1] = qy;\n    this.bodyQuaternions[offset + 2] = qz;\n    this.bodyQuaternions[offset + 3] = qw;\n\n    // Mass (store as inverse)\n    this.bodyMasses[offset] = inertiaX > 0 ? 1 / inertiaX : 0;\n    this.bodyMasses[offset + 1] = inertiaY > 0 ? 1 / inertiaY : 0;\n    this.bodyMasses[offset + 2] = inertiaZ > 0 ? 1 / inertiaZ : 0;\n    this.bodyMasses[offset + 3] = mass > 0 ? 1 / mass : 0;\n\n    this._bodyCount++;\n    this.bodyDataDirty = true;\n    this.massDirty = true;\n\n    return id;\n  }\n\n  /**\n   * Add a collision particle to a body\n   */\n  addParticle(bodyId: number, x: number, y: number, z: number): number {\n    if (this._particleCount >= this.maxParticles) {\n      console.warn(`Cannot add particle: maximum (${this.maxParticles}) reached`);\n      return -1;\n    }\n\n    const id = this._particleCount;\n    const offset = id * 4;\n\n    this.particleLocalPositions[offset] = x;\n    this.particleLocalPositions[offset + 1] = y;\n    this.particleLocalPositions[offset + 2] = z;\n    this.particleLocalPositions[offset + 3] = bodyId;\n\n    this._particleCount++;\n    this.particleDataDirty = true;\n\n    return id;\n  }\n\n  /**\n   * Step the simulation forward by deltaTime\n   */\n  step(deltaTime: number): void {\n    if (!this.initialized) {\n      console.warn('World not initialized. Call await world.ready() first.');\n      return;\n    }\n\n    this.accumulator += deltaTime;\n    let substeps = 0;\n\n    while (this.accumulator >= this.params.fixedTimeStep && substeps < this.maxSubSteps) {\n      this.singleStep();\n      this.accumulator -= this.params.fixedTimeStep;\n      substeps++;\n    }\n\n    this._interpolationValue = this.accumulator / this.params.fixedTimeStep;\n    this.time += deltaTime;\n  }\n\n  /**\n   * Execute a single physics step\n   */\n  private singleStep(): void {\n    this.flushData();\n\n    const encoder = this.device.createCommandEncoder({ label: 'physics-step' });\n    \n    // Reset accumulators and grid particle slots each step\n    encoder.clearBuffer(this.buffers.bodyForce);\n    encoder.clearBuffer(this.buffers.bodyTorque);\n    encoder.clearBuffer(this.buffers.gridCellParticles);\n    \n    const particleDispatch = getDispatchSize(this._particleCount, WORKGROUP_SIZE);\n    const bodyDispatch = getDispatchSize(this._bodyCount, WORKGROUP_SIZE);\n    const gridCellCount = Math.ceil(this.grid.resolution[0]) * \n                          Math.ceil(this.grid.resolution[1]) * \n                          Math.ceil(this.grid.resolution[2]);\n    const gridDispatch = getDispatchSize(gridCellCount, WORKGROUP_SIZE);\n\n    // 1. Transform local particle positions to world space\n    {\n      const pass = encoder.beginComputePass({ label: 'local-to-world' });\n      pass.setPipeline(this.pipelines.localToWorld);\n      pass.setBindGroup(0, this.bindGroups.get('localToWorld')!);\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n\n    // 2. Compute relative particle positions\n    {\n      const pass = encoder.beginComputePass({ label: 'local-to-relative' });\n      pass.setPipeline(this.pipelines.localToRelative);\n      pass.setBindGroup(0, this.bindGroups.get('localToRelative')!);\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n\n    // 3. Derive particle velocities from body velocities\n    {\n      const pass = encoder.beginComputePass({ label: 'body-vel-to-particle-vel' });\n      pass.setPipeline(this.pipelines.bodyVelToParticleVel);\n      pass.setBindGroup(0, this.bindGroups.get('bodyVelToParticleVel')!);\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n\n    // 4. Clear grid\n    {\n      const pass = encoder.beginComputePass({ label: 'clear-grid' });\n      pass.setPipeline(this.pipelines.clearGrid);\n      pass.setBindGroup(0, this.bindGroups.get('clearGrid')!);\n      pass.dispatchWorkgroups(gridDispatch);\n      pass.end();\n    }\n\n    // 5. Build spatial hash grid\n    {\n      const pass = encoder.beginComputePass({ label: 'build-grid' });\n      pass.setPipeline(this.pipelines.buildGrid);\n      pass.setBindGroup(0, this.bindGroups.get('buildGrid')!);\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n\n    // 6. Calculate particle forces\n    {\n      const pass = encoder.beginComputePass({ label: 'update-force' });\n      pass.setPipeline(this.pipelines.updateForce);\n      pass.setBindGroup(0, this.bindGroups.get('updateForce')!);\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n\n    // 7. Calculate particle torques\n    {\n      const pass = encoder.beginComputePass({ label: 'update-torque' });\n      pass.setPipeline(this.pipelines.updateTorque);\n      pass.setBindGroup(0, this.bindGroups.get('updateTorque')!);\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n\n    // 8. Reduce particle forces to body forces\n    {\n      const pass = encoder.beginComputePass({ label: 'reduce-force' });\n      pass.setPipeline(this.pipelines.reduceForce);\n      pass.setBindGroup(0, this.bindGroups.get('reduceForce')!);\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n\n    // 9. Reduce particle torques to body torques\n    {\n      const pass = encoder.beginComputePass({ label: 'reduce-torque' });\n      pass.setPipeline(this.pipelines.reduceTorque);\n      pass.setBindGroup(0, this.bindGroups.get('reduceTorque')!);\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n\n    // 10. Update body velocities\n    {\n      const pass = encoder.beginComputePass({ label: 'update-body-velocity' });\n      pass.setPipeline(this.pipelines.updateBodyVelocity);\n      pass.setBindGroup(0, this.bindGroups.get('updateBodyVelocity')!);\n      pass.dispatchWorkgroups(bodyDispatch);\n      pass.end();\n    }\n\n    // 11. Update body angular velocities\n    {\n      const pass = encoder.beginComputePass({ label: 'update-body-angular-velocity' });\n      pass.setPipeline(this.pipelines.updateBodyAngularVelocity);\n      pass.setBindGroup(0, this.bindGroups.get('updateBodyAngularVelocity')!);\n      pass.dispatchWorkgroups(bodyDispatch);\n      pass.end();\n    }\n\n    // 12. Update body positions\n    {\n      const pass = encoder.beginComputePass({ label: 'update-body-position' });\n      pass.setPipeline(this.pipelines.updateBodyPosition);\n      pass.setBindGroup(0, this.bindGroups.get('updateBodyPosition')!);\n      pass.dispatchWorkgroups(bodyDispatch);\n      pass.end();\n    }\n\n    // 13. Update body quaternions\n    {\n      const pass = encoder.beginComputePass({ label: 'update-body-quaternion' });\n      pass.setPipeline(this.pipelines.updateBodyQuaternion);\n      pass.setBindGroup(0, this.bindGroups.get('updateBodyQuaternion')!);\n      pass.dispatchWorkgroups(bodyDispatch);\n      pass.end();\n    }\n\n    // Submit command buffer\n    this.device.queue.submit([encoder.finish()]);\n\n    // Swap buffers for next frame\n    this.swapBuffers();\n\n    this.fixedTime += this.params.fixedTimeStep;\n  }\n\n  // Property getters and setters\n  get bodyCount(): number { return this._bodyCount; }\n  get particleCount(): number { return this._particleCount; }\n  get interpolationValue(): number { return this._interpolationValue; }\n  \n  get stiffness(): number { return this.params.stiffness; }\n  set stiffness(v: number) { this.params.stiffness = v; }\n  \n  get damping(): number { return this.params.damping; }\n  set damping(v: number) { this.params.damping = v; }\n  \n  get friction(): number { return this.params.friction; }\n  set friction(v: number) { this.params.friction = v; }\n  \n  get drag(): number { return this.params.drag; }\n  set drag(v: number) { this.params.drag = v; }\n  \n  get radius(): number { return this.params.radius; }\n  set radius(v: number) { this.params.radius = v; }\n  \n  get fixedTimeStep(): number { return this.params.fixedTimeStep; }\n  set fixedTimeStep(v: number) { this.params.fixedTimeStep = v; }\n  \n  get gravity(): Vec3 { \n    return new Vec3(this.params.gravity[0], this.params.gravity[1], this.params.gravity[2]); \n  }\n  set gravity(v: Vec3) { \n    this.params.gravity[0] = v.x;\n    this.params.gravity[1] = v.y;\n    this.params.gravity[2] = v.z;\n  }\n\n  /**\n   * Set interaction sphere position\n   */\n  setSpherePosition(index: number, x: number, y: number, z: number): void {\n    if (index !== 0) throw new Error('Multiple spheres not supported yet');\n    this.interactionSphere.position.set(x, y, z);\n  }\n\n  /**\n   * Get interaction sphere position\n   */\n  getSpherePosition(index: number, out?: Vec3): Vec3 {\n    if (index !== 0) throw new Error('Multiple spheres not supported yet');\n    out = out || new Vec3();\n    out.copy(this.interactionSphere.position);\n    return out;\n  }\n\n  /**\n   * Set interaction sphere radius\n   */\n  setSphereRadius(index: number, radius: number): void {\n    if (index !== 0) throw new Error('Multiple spheres not supported yet');\n    this.interactionSphere.radius = radius;\n  }\n\n  /**\n   * Get interaction sphere radius\n   */\n  getSphereRadius(index: number): number {\n    if (index !== 0) throw new Error('Multiple spheres not supported yet');\n    return this.interactionSphere.radius;\n  }\n\n  /**\n   * Read body positions from GPU (async)\n   */\n  async readBodyPositions(): Promise<Float32Array> {\n    const size = this._bodyCount * 4 * 4;\n    const posBuffer = this.bufferIndex === 0 \n      ? this.buffers.bodyPositionA \n      : this.buffers.bodyPositionB;\n    const data = await readBuffer(this.device, posBuffer, this.buffers.stagingPosition, size);\n    return new Float32Array(data);\n  }\n\n  /**\n   * Read body quaternions from GPU (async)\n   */\n  async readBodyQuaternions(): Promise<Float32Array> {\n    const size = this._bodyCount * 4 * 4;\n    const quatBuffer = this.bufferIndex === 0 \n      ? this.buffers.bodyQuaternionA \n      : this.buffers.bodyQuaternionB;\n    const data = await readBuffer(this.device, quatBuffer, this.buffers.stagingQuaternion, size);\n    return new Float32Array(data);\n  }\n\n  /**\n   * Get the WebGPU device (for rendering integration)\n   */\n  getDevice(): GPUDevice {\n    return this.device;\n  }\n\n  /**\n   * Get body position buffer for rendering\n   */\n  getBodyPositionBuffer(): GPUBuffer {\n    return this.bufferIndex === 0 \n      ? this.buffers.bodyPositionA \n      : this.buffers.bodyPositionB;\n  }\n\n  /**\n   * Get body quaternion buffer for rendering  \n   */\n  getBodyQuaternionBuffer(): GPUBuffer {\n    return this.bufferIndex === 0 \n      ? this.buffers.bodyQuaternionA \n      : this.buffers.bodyQuaternionB;\n  }\n\n  /**\n   * Destroy all GPU resources\n   */\n  destroy(): void {\n    if (!this.initialized) return;\n\n    // Destroy all buffers\n    Object.values(this.buffers).forEach(buffer => {\n      if (buffer && typeof buffer.destroy === 'function') {\n        buffer.destroy();\n      }\n    });\n\n    this.bindGroups.clear();\n    this.initialized = false;\n  }\n}\n","/**\n * WebGPU Physics - High-performance GPU-accelerated physics simulation\n * \n * A port of gpu-physics.js from WebGL to WebGPU compute shaders\n */\n\nexport { World, type WorldOptions } from './world';\nexport { initWebGPU, isWebGPUSupported, type WebGPUContext } from './device';\nexport { Vec3, Vec4, Quat, Mat3 } from './math';\nexport type { PhysicsBody, PhysicsParticle } from './types';\n\n// Re-export constants\nexport const VERSION = '1.0.0';\n"],"names":["Vec3","x","y","z","__publicField","v","s","ax","ay","az","bx","by","bz","len","a","b","out","Vec4","w","Quat","q","invLen","angularVelocity","dt","halfDt","wx","wy","wz","qx","qy","qz","qw","ix","iy","iz","iw","axis","angle","halfAngle","aw","bw","t","d","theta0","theta","sinTheta","sinTheta0","s0","s1","Mat3","x2","y2","z2","xx","xy","xz","yy","yz","zz","m","tmp","ae","be","isWebGPUSupported","initWebGPU","adapter","adapterInfo","requiredFeatures","requiredLimits","device","info","event","createShaderModule","code","label","createStorageBuffer","size","mappedAtCreation","createUniformBuffer","createStagingBuffer","writeBuffer","buffer","data","offset","readBuffer","sourceBuffer","stagingBuffer","commandEncoder","copyData","alignTo","alignment","getDispatchSize","numElements","workgroupSize","sharedWgsl","localToWorldWgsl","localToRelativeWgsl","bodyVelToParticleVelWgsl","clearGridWgsl","buildGridWgsl","updateForceWgsl","updateTorqueWgsl","reduceForceWgsl","reduceTorqueWgsl","updateBodyVelocityWgsl","updateBodyAngularVelocityWgsl","updateBodyPositionWgsl","updateBodyQuaternionWgsl","WORKGROUP_SIZE","MAX_PARTICLES_PER_CELL","World","options","_a","_b","_c","gridRes","i","bodySize","particleSize","gridCellCount","gridSize","gridParticlesSize","makeShader","bufferLayout","binding","type","makeLayout","entries","makePipeline","module","layout","modules","layouts","buffers","posRead","posWrite","quatRead","quatWrite","velRead","velWrite","angVelRead","angVelWrite","maxV","mass","inertiaX","inertiaY","inertiaZ","id","bodyId","deltaTime","substeps","encoder","particleDispatch","bodyDispatch","gridDispatch","pass","index","radius","posBuffer","quatBuffer","VERSION"],"mappings":";;;AAQO,MAAMA,EAAK;AAAA,EAGhB,YAAYC,IAAI,GAAGC,IAAI,GAAGC,IAAI,GAAG;AAF1B,IAAAC,EAAA;AAGL,SAAK,OAAO,IAAI,aAAa,CAACH,GAAGC,GAAGC,CAAC,CAAC;AAAA,EACxC;AAAA,EAEA,IAAI,IAAY;AAAE,WAAO,KAAK,KAAK,CAAC;AAAA,EAAG;AAAA,EACvC,IAAI,EAAEE,GAAW;AAAE,SAAK,KAAK,CAAC,IAAIA;AAAA,EAAG;AAAA,EACrC,IAAI,IAAY;AAAE,WAAO,KAAK,KAAK,CAAC;AAAA,EAAG;AAAA,EACvC,IAAI,EAAEA,GAAW;AAAE,SAAK,KAAK,CAAC,IAAIA;AAAA,EAAG;AAAA,EACrC,IAAI,IAAY;AAAE,WAAO,KAAK,KAAK,CAAC;AAAA,EAAG;AAAA,EACvC,IAAI,EAAEA,GAAW;AAAE,SAAK,KAAK,CAAC,IAAIA;AAAA,EAAG;AAAA,EAErC,IAAIJ,GAAWC,GAAWC,GAAiB;AACzC,gBAAK,KAAK,CAAC,IAAIF,GACf,KAAK,KAAK,CAAC,IAAIC,GACf,KAAK,KAAK,CAAC,IAAIC,GACR;AAAA,EACT;AAAA,EAEA,KAAKE,GAAe;AAClB,gBAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,GACvB,KAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,GACvB,KAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,GAChB;AAAA,EACT;AAAA,EAEA,QAAc;AACZ,WAAO,IAAIL,EAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAAA,EACxC;AAAA,EAEA,IAAIK,GAAe;AACjB,gBAAK,KAAK,CAAC,KAAKA,EAAE,KAAK,CAAC,GACxB,KAAK,KAAK,CAAC,KAAKA,EAAE,KAAK,CAAC,GACxB,KAAK,KAAK,CAAC,KAAKA,EAAE,KAAK,CAAC,GACjB;AAAA,EACT;AAAA,EAEA,IAAIA,GAAe;AACjB,gBAAK,KAAK,CAAC,KAAKA,EAAE,KAAK,CAAC,GACxB,KAAK,KAAK,CAAC,KAAKA,EAAE,KAAK,CAAC,GACxB,KAAK,KAAK,CAAC,KAAKA,EAAE,KAAK,CAAC,GACjB;AAAA,EACT;AAAA,EAEA,MAAMC,GAAiB;AACrB,gBAAK,KAAK,CAAC,KAAKA,GAChB,KAAK,KAAK,CAAC,KAAKA,GAChB,KAAK,KAAK,CAAC,KAAKA,GACT;AAAA,EACT;AAAA,EAEA,IAAID,GAAiB;AACnB,WAAO,KAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC;AAAA,EACtF;AAAA,EAEA,MAAMA,GAAe;AACnB,UAAME,IAAK,KAAK,KAAK,CAAC,GAAGC,IAAK,KAAK,KAAK,CAAC,GAAGC,IAAK,KAAK,KAAK,CAAC,GACtDC,IAAKL,EAAE,KAAK,CAAC,GAAGM,IAAKN,EAAE,KAAK,CAAC,GAAGO,IAAKP,EAAE,KAAK,CAAC;AACnD,gBAAK,KAAK,CAAC,IAAIG,IAAKI,IAAKH,IAAKE,GAC9B,KAAK,KAAK,CAAC,IAAIF,IAAKC,IAAKH,IAAKK,GAC9B,KAAK,KAAK,CAAC,IAAIL,IAAKI,IAAKH,IAAKE,GACvB;AAAA,EACT;AAAA,EAEA,SAAiB;AACf,WAAO,KAAK,KAAK,KAAK,IAAI,IAAI,CAAC;AAAA,EACjC;AAAA,EAEA,WAAmB;AACjB,WAAO,KAAK,IAAI,IAAI;AAAA,EACtB;AAAA,EAEA,YAAkB;AAChB,UAAMG,IAAM,KAAK,OAAA;AACjB,WAAIA,IAAM,KACR,KAAK,MAAM,IAAIA,CAAG,GAEb;AAAA,EACT;AAAA,EAEA,OAAO,MAAMC,GAASC,GAASC,GAAkB;AAC/C,WAAAA,IAAMA,KAAO,IAAIhB,EAAA,GACjBgB,EAAI,KAAK,CAAC,IAAIF,EAAE,IAAIC,EAAE,IAAID,EAAE,IAAIC,EAAE,GAClCC,EAAI,KAAK,CAAC,IAAIF,EAAE,IAAIC,EAAE,IAAID,EAAE,IAAIC,EAAE,GAClCC,EAAI,KAAK,CAAC,IAAIF,EAAE,IAAIC,EAAE,IAAID,EAAE,IAAIC,EAAE,GAC3BC;AAAA,EACT;AAAA,EAEA,OAAO,IAAIF,GAASC,GAAiB;AACnC,WAAOD,EAAE,IAAIC,EAAE,IAAID,EAAE,IAAIC,EAAE,IAAID,EAAE,IAAIC,EAAE;AAAA,EACzC;AACF;AAKO,MAAME,EAAK;AAAA,EAGhB,YAAYhB,IAAI,GAAGC,IAAI,GAAGC,IAAI,GAAGe,IAAI,GAAG;AAFjC,IAAAd,EAAA;AAGL,SAAK,OAAO,IAAI,aAAa,CAACH,GAAGC,GAAGC,GAAGe,CAAC,CAAC;AAAA,EAC3C;AAAA,EAEA,IAAI,IAAY;AAAE,WAAO,KAAK,KAAK,CAAC;AAAA,EAAG;AAAA,EACvC,IAAI,EAAEb,GAAW;AAAE,SAAK,KAAK,CAAC,IAAIA;AAAA,EAAG;AAAA,EACrC,IAAI,IAAY;AAAE,WAAO,KAAK,KAAK,CAAC;AAAA,EAAG;AAAA,EACvC,IAAI,EAAEA,GAAW;AAAE,SAAK,KAAK,CAAC,IAAIA;AAAA,EAAG;AAAA,EACrC,IAAI,IAAY;AAAE,WAAO,KAAK,KAAK,CAAC;AAAA,EAAG;AAAA,EACvC,IAAI,EAAEA,GAAW;AAAE,SAAK,KAAK,CAAC,IAAIA;AAAA,EAAG;AAAA,EACrC,IAAI,IAAY;AAAE,WAAO,KAAK,KAAK,CAAC;AAAA,EAAG;AAAA,EACvC,IAAI,EAAEA,GAAW;AAAE,SAAK,KAAK,CAAC,IAAIA;AAAA,EAAG;AAAA,EAErC,IAAIJ,GAAWC,GAAWC,GAAWe,GAAiB;AACpD,gBAAK,KAAK,CAAC,IAAIjB,GACf,KAAK,KAAK,CAAC,IAAIC,GACf,KAAK,KAAK,CAAC,IAAIC,GACf,KAAK,KAAK,CAAC,IAAIe,GACR;AAAA,EACT;AAAA,EAEA,KAAKb,GAAe;AAClB,gBAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,GACvB,KAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,GACvB,KAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,GACvB,KAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,GAChB;AAAA,EACT;AAAA,EAEA,QAAc;AACZ,WAAO,IAAIY,EAAK,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAAA,EAChD;AACF;AAKO,MAAME,EAAK;AAAA,EAGhB,YAAYlB,IAAI,GAAGC,IAAI,GAAGC,IAAI,GAAGe,IAAI,GAAG;AAFjC,IAAAd,EAAA;AAGL,SAAK,OAAO,IAAI,aAAa,CAACH,GAAGC,GAAGC,GAAGe,CAAC,CAAC;AAAA,EAC3C;AAAA,EAEA,IAAI,IAAY;AAAE,WAAO,KAAK,KAAK,CAAC;AAAA,EAAG;AAAA,EACvC,IAAI,EAAEb,GAAW;AAAE,SAAK,KAAK,CAAC,IAAIA;AAAA,EAAG;AAAA,EACrC,IAAI,IAAY;AAAE,WAAO,KAAK,KAAK,CAAC;AAAA,EAAG;AAAA,EACvC,IAAI,EAAEA,GAAW;AAAE,SAAK,KAAK,CAAC,IAAIA;AAAA,EAAG;AAAA,EACrC,IAAI,IAAY;AAAE,WAAO,KAAK,KAAK,CAAC;AAAA,EAAG;AAAA,EACvC,IAAI,EAAEA,GAAW;AAAE,SAAK,KAAK,CAAC,IAAIA;AAAA,EAAG;AAAA,EACrC,IAAI,IAAY;AAAE,WAAO,KAAK,KAAK,CAAC;AAAA,EAAG;AAAA,EACvC,IAAI,EAAEA,GAAW;AAAE,SAAK,KAAK,CAAC,IAAIA;AAAA,EAAG;AAAA,EAErC,IAAIJ,GAAWC,GAAWC,GAAWe,GAAiB;AACpD,gBAAK,KAAK,CAAC,IAAIjB,GACf,KAAK,KAAK,CAAC,IAAIC,GACf,KAAK,KAAK,CAAC,IAAIC,GACf,KAAK,KAAK,CAAC,IAAIe,GACR;AAAA,EACT;AAAA,EAEA,KAAKE,GAAe;AAClB,gBAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,GACvB,KAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,GACvB,KAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,GACvB,KAAK,KAAK,CAAC,IAAIA,EAAE,KAAK,CAAC,GAChB;AAAA,EACT;AAAA,EAEA,QAAc;AACZ,WAAO,IAAID,EAAK,KAAK,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AAAA,EAChD;AAAA,EAEA,WAAiB;AACf,WAAO,KAAK,IAAI,GAAG,GAAG,GAAG,CAAC;AAAA,EAC5B;AAAA,EAEA,SAAiB;AACf,WAAO,KAAK,KAAK,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,IAAI,KAAK,CAAC;AAAA,EACxF;AAAA,EAEA,YAAkB;AAChB,UAAMN,IAAM,KAAK,OAAA;AACjB,QAAIA,IAAM,GAAG;AACX,YAAMQ,IAAS,IAAIR;AACnB,WAAK,KAAK,CAAC,KAAKQ,GAChB,KAAK,KAAK,CAAC,KAAKA,GAChB,KAAK,KAAK,CAAC,KAAKA,GAChB,KAAK,KAAK,CAAC,KAAKA;AAAA,IAClB;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAUC,GAAuBC,GAAkB;AACjD,UAAMC,IAASD,IAAK,KACdE,IAAKH,EAAgB,GACrBI,IAAKJ,EAAgB,GACrBK,IAAKL,EAAgB;AAE3B,gBAAK,KAAK,CAAC,KAAKE,KAAUC,IAAK,KAAK,IAAIC,IAAK,KAAK,IAAIC,IAAK,KAAK,IAChE,KAAK,KAAK,CAAC,KAAKH,KAAUE,IAAK,KAAK,IAAIC,IAAK,KAAK,IAAIF,IAAK,KAAK,IAChE,KAAK,KAAK,CAAC,KAAKD,KAAUG,IAAK,KAAK,IAAIF,IAAK,KAAK,IAAIC,IAAK,KAAK,IAChE,KAAK,KAAK,CAAC,KAAKF,KAAU,CAACC,IAAK,KAAK,IAAIC,IAAK,KAAK,IAAIC,IAAK,KAAK,IAE1D,KAAK,UAAA;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAYtB,GAASW,GAAkB;AACrC,IAAAA,IAAMA,KAAO,IAAIhB,EAAA;AAEjB,UAAMC,IAAII,EAAE,GAAGH,IAAIG,EAAE,GAAGF,IAAIE,EAAE,GACxBuB,IAAK,KAAK,GAAGC,IAAK,KAAK,GAAGC,IAAK,KAAK,GAAGC,IAAK,KAAK,GAEjDC,IAAKD,IAAK9B,IAAI4B,IAAK1B,IAAI2B,IAAK5B,GAC5B+B,IAAKF,IAAK7B,IAAI4B,IAAK7B,IAAI2B,IAAKzB,GAC5B+B,IAAKH,IAAK5B,IAAIyB,IAAK1B,IAAI2B,IAAK5B,GAC5BkC,IAAK,CAACP,IAAK3B,IAAI4B,IAAK3B,IAAI4B,IAAK3B;AAEnC,WAAAa,EAAI,KAAK,CAAC,IAAIgB,IAAKD,IAAKI,IAAK,CAACP,IAAKK,IAAK,CAACH,IAAKI,IAAK,CAACL,GACpDb,EAAI,KAAK,CAAC,IAAIiB,IAAKF,IAAKI,IAAK,CAACN,IAAKK,IAAK,CAACN,IAAKI,IAAK,CAACF,GACpDd,EAAI,KAAK,CAAC,IAAIkB,IAAKH,IAAKI,IAAK,CAACL,IAAKE,IAAK,CAACH,IAAKI,IAAK,CAACL,GAE7CZ;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiBoB,GAAYC,GAAqB;AAChD,UAAMC,IAAYD,IAAQ,KACpB/B,IAAI,KAAK,IAAIgC,CAAS;AAC5B,gBAAK,KAAK,CAAC,IAAIF,EAAK,IAAI9B,GACxB,KAAK,KAAK,CAAC,IAAI8B,EAAK,IAAI9B,GACxB,KAAK,KAAK,CAAC,IAAI8B,EAAK,IAAI9B,GACxB,KAAK,KAAK,CAAC,IAAI,KAAK,IAAIgC,CAAS,GAC1B;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,SAASlB,GAAe;AACtB,UAAMb,IAAK,KAAK,GAAGC,IAAK,KAAK,GAAGC,IAAK,KAAK,GAAG8B,IAAK,KAAK,GACjD7B,IAAKU,EAAE,GAAGT,IAAKS,EAAE,GAAGR,IAAKQ,EAAE,GAAGoB,IAAKpB,EAAE;AAE3C,gBAAK,KAAK,CAAC,IAAIb,IAAKiC,IAAKD,IAAK7B,IAAKF,IAAKI,IAAKH,IAAKE,GAClD,KAAK,KAAK,CAAC,IAAIH,IAAKgC,IAAKD,IAAK5B,IAAKF,IAAKC,IAAKH,IAAKK,GAClD,KAAK,KAAK,CAAC,IAAIH,IAAK+B,IAAKD,IAAK3B,IAAKL,IAAKI,IAAKH,IAAKE,GAClD,KAAK,KAAK,CAAC,IAAI6B,IAAKC,IAAKjC,IAAKG,IAAKF,IAAKG,IAAKF,IAAKG,GAE3C;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,MAAME,GAASC,GAAS0B,GAAWzB,GAAkB;AAC1D,IAAAA,IAAMA,KAAO,IAAIG,EAAA;AAEjB,QAAIuB,IAAI5B,EAAE,IAAIC,EAAE,IAAID,EAAE,IAAIC,EAAE,IAAID,EAAE,IAAIC,EAAE,IAAID,EAAE,IAAIC,EAAE,GAGhDL,IAAKK,EAAE,GAAGJ,IAAKI,EAAE,GAAGH,IAAKG,EAAE,GAAGyB,IAAKzB,EAAE;AAMzC,QALI2B,IAAI,MACNhC,IAAK,CAACA,GAAIC,IAAK,CAACA,GAAIC,IAAK,CAACA,GAAI4B,IAAK,CAACA,GACpCE,IAAI,CAACA,IAGHA,IAAI;AAEN,aAAA1B,EAAI,KAAK,CAAC,IAAIF,EAAE,IAAI2B,KAAK/B,IAAKI,EAAE,IAChCE,EAAI,KAAK,CAAC,IAAIF,EAAE,IAAI2B,KAAK9B,IAAKG,EAAE,IAChCE,EAAI,KAAK,CAAC,IAAIF,EAAE,IAAI2B,KAAK7B,IAAKE,EAAE,IAChCE,EAAI,KAAK,CAAC,IAAIF,EAAE,IAAI2B,KAAKD,IAAK1B,EAAE,IACzBE,EAAI,UAAA;AAGb,UAAM2B,IAAS,KAAK,KAAKD,CAAC,GACpBE,IAAQD,IAASF,GACjBI,IAAW,KAAK,IAAID,CAAK,GACzBE,IAAY,KAAK,IAAIH,CAAM,GAE3BI,IAAK,KAAK,IAAIH,CAAK,IAAIF,IAAIG,IAAWC,GACtCE,IAAKH,IAAWC;AAEtB,WAAA9B,EAAI,KAAK,CAAC,IAAIF,EAAE,IAAIiC,IAAKrC,IAAKsC,GAC9BhC,EAAI,KAAK,CAAC,IAAIF,EAAE,IAAIiC,IAAKpC,IAAKqC,GAC9BhC,EAAI,KAAK,CAAC,IAAIF,EAAE,IAAIiC,IAAKnC,IAAKoC,GAC9BhC,EAAI,KAAK,CAAC,IAAIF,EAAE,IAAIiC,IAAKP,IAAKQ,GAEvBhC;AAAA,EACT;AACF;AAKO,MAAMiC,EAAK;AAAA,EAGhB,cAAc;AAFP,IAAA7C,EAAA;AAGL,SAAK,OAAO,IAAI,aAAa,CAAC,GAC9B,KAAK,SAAA;AAAA,EACP;AAAA,EAEA,WAAiB;AACf,gBAAK,KAAK,KAAK,CAAC,GAChB,KAAK,KAAK,CAAC,IAAI,GACf,KAAK,KAAK,CAAC,IAAI,GACf,KAAK,KAAK,CAAC,IAAI,GACR;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAASgB,GAAe;AACtB,UAAMnB,IAAImB,EAAE,GAAGlB,IAAIkB,EAAE,GAAGjB,IAAIiB,EAAE,GAAGF,IAAIE,EAAE,GACjC8B,IAAKjD,IAAIA,GAAGkD,IAAKjD,IAAIA,GAAGkD,IAAKjD,IAAIA,GACjCkD,IAAKpD,IAAIiD,GAAII,IAAKrD,IAAIkD,GAAII,IAAKtD,IAAImD,GACnCI,IAAKtD,IAAIiD,GAAIM,IAAKvD,IAAIkD,GAAIM,IAAKvD,IAAIiD,GACnC3B,IAAKP,IAAIgC,GAAIxB,IAAKR,IAAIiC,GAAIxB,IAAKT,IAAIkC;AAGzC,gBAAK,KAAK,CAAC,IAAI,KAAKI,IAAKE,IACzB,KAAK,KAAK,CAAC,IAAIJ,IAAK3B,GACpB,KAAK,KAAK,CAAC,IAAI4B,IAAK7B,GAEpB,KAAK,KAAK,CAAC,IAAI4B,IAAK3B,GACpB,KAAK,KAAK,CAAC,IAAI,KAAK0B,IAAKK,IACzB,KAAK,KAAK,CAAC,IAAID,IAAKhC,GAEpB,KAAK,KAAK,CAAC,IAAI8B,IAAK7B,GACpB,KAAK,KAAK,CAAC,IAAI+B,IAAKhC,GACpB,KAAK,KAAK,CAAC,IAAI,KAAK4B,IAAKG,IAElB;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,YAAkB;AAChB,UAAMG,IAAI,KAAK;AACf,QAAIC;AACJ,WAAAA,IAAMD,EAAE,CAAC,GAAGA,EAAE,CAAC,IAAIA,EAAE,CAAC,GAAGA,EAAE,CAAC,IAAIC,GAChCA,IAAMD,EAAE,CAAC,GAAGA,EAAE,CAAC,IAAIA,EAAE,CAAC,GAAGA,EAAE,CAAC,IAAIC,GAChCA,IAAMD,EAAE,CAAC,GAAGA,EAAE,CAAC,IAAIA,EAAE,CAAC,GAAGA,EAAE,CAAC,IAAIC,GACzB;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS7C,GAAe;AACtB,UAAMD,IAAI,KAAK,MACT+C,IAAK,CAAC,GAAG/C,CAAC,GACVgD,IAAK/C,EAAE;AAEb,WAAAD,EAAE,CAAC,IAAI+C,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,GACnDhD,EAAE,CAAC,IAAI+C,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,GACnDhD,EAAE,CAAC,IAAI+C,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,GAEnDhD,EAAE,CAAC,IAAI+C,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,GACnDhD,EAAE,CAAC,IAAI+C,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,GACnDhD,EAAE,CAAC,IAAI+C,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,GAEnDhD,EAAE,CAAC,IAAI+C,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,GACnDhD,EAAE,CAAC,IAAI+C,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,GACnDhD,EAAE,CAAC,IAAI+C,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,IAAID,EAAG,CAAC,IAAIC,EAAG,CAAC,GAE5C;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,YAAYzD,GAASW,GAAkB;AACrC,IAAAA,IAAMA,KAAO,IAAIhB,EAAA;AACjB,UAAM2D,IAAI,KAAK,MACT1D,IAAII,EAAE,GAAGH,IAAIG,EAAE,GAAGF,IAAIE,EAAE;AAC9B,WAAAW,EAAI,KAAK,CAAC,IAAI2C,EAAE,CAAC,IAAI1D,IAAI0D,EAAE,CAAC,IAAIzD,IAAIyD,EAAE,CAAC,IAAIxD,GAC3Ca,EAAI,KAAK,CAAC,IAAI2C,EAAE,CAAC,IAAI1D,IAAI0D,EAAE,CAAC,IAAIzD,IAAIyD,EAAE,CAAC,IAAIxD,GAC3Ca,EAAI,KAAK,CAAC,IAAI2C,EAAE,CAAC,IAAI1D,IAAI0D,EAAE,CAAC,IAAIzD,IAAIyD,EAAE,CAAC,IAAIxD,GACpCa;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,YAAYX,GAAe;AACzB,gBAAK,KAAK,KAAK,CAAC,GAChB,KAAK,KAAK,CAAC,IAAIA,EAAE,GACjB,KAAK,KAAK,CAAC,IAAIA,EAAE,GACjB,KAAK,KAAK,CAAC,IAAIA,EAAE,GACV;AAAA,EACT;AAAA,EAEA,QAAc;AACZ,UAAMsD,IAAI,IAAIV,EAAA;AACd,WAAAU,EAAE,KAAK,IAAI,KAAK,IAAI,GACbA;AAAA,EACT;AACF;ACpZO,SAASI,IAA6B;AAC3C,SAAO,OAAO,YAAc,OAAe,SAAS;AACtD;AAMA,eAAsBC,IAAqC;AACzD,MAAI,CAACD;AACH,UAAM,IAAI,MAAM,6GAA6G;AAM/H,QAAME,IAAU,MAHJ,UAAU,IAGI,eAAe;AAAA,IACvC,iBAAiB;AAAA,EAAA,CAClB;AAED,MAAI,CAACA;AACH,UAAM,IAAI,MAAM,gEAAgE;AAIlF,QAAMC,IAAcD,EAAQ;AAC5B,UAAQ,IAAI,mBAAmB;AAAA,IAC7B,QAAQC,EAAY;AAAA,IACpB,cAAcA,EAAY;AAAA,IAC1B,QAAQA,EAAY;AAAA,IACpB,aAAaA,EAAY;AAAA,EAAA,CAC1B;AAGD,QAAMC,IAAqC,CAAA,GACrCC,IAAyC;AAAA,IAC7C,6BAA6BH,EAAQ,OAAO;AAAA,IAC5C,kCAAkCA,EAAQ,OAAO;AAAA,IACjD,mCAAmCA,EAAQ,OAAO;AAAA,IAClD,0BAA0BA,EAAQ,OAAO;AAAA,IACzC,0BAA0BA,EAAQ,OAAO;AAAA,IACzC,0BAA0BA,EAAQ,OAAO;AAAA,EAAA;AAI3C,EAAIA,EAAQ,SAAS,IAAI,iBAAiB,KACxCE,EAAiB,KAAK,iBAAiB;AAGzC,QAAME,IAAS,MAAMJ,EAAQ,cAAc;AAAA,IACzC,kBAAAE;AAAA,IACA,gBAAAC;AAAA,EAAA,CACD;AAGD,SAAAC,EAAO,KAAK,KAAK,CAACC,MAAS;AACzB,YAAQ,MAAM,uBAAuBA,EAAK,OAAO,GAC7CA,EAAK,WAAW,eAElB,QAAQ,MAAM,uBAAuBA,EAAK,MAAM;AAAA,EAEpD,CAAC,GAGDD,EAAO,oBAAoB,CAACE,MAAU;AACpC,YAAQ,MAAM,4BAA4BA,EAAM,KAAK;AAAA,EACvD,GAEO;AAAA,IACL,SAAAN;AAAA,IACA,QAAAI;AAAA,IACA,UAAUA,EAAO;AAAA,IACjB,QAAQA,EAAO;AAAA,EAAA;AAEnB;AAKO,SAASG,EAAmBH,GAAmBI,GAAcC,GAAiC;AACnG,SAAOL,EAAO,mBAAmB;AAAA,IAC/B,OAAOK,KAAS;AAAA,IAChB,MAAAD;AAAA,EAAA,CACD;AACH;AAyBO,SAASE,EACdN,GACAO,GACAF,GACAG,IAAmB,IACR;AACX,SAAOR,EAAO,aAAa;AAAA,IACzB,OAAOK,KAAS;AAAA,IAChB,MAAAE;AAAA,IACA,OAAO,eAAe,UAAU,eAAe,WAAW,eAAe;AAAA,IACzE,kBAAAC;AAAA,EAAA,CACD;AACH;AAKO,SAASC,EACdT,GACAO,GACAF,GACW;AACX,SAAOL,EAAO,aAAa;AAAA,IACzB,OAAOK;AAAA,IACP,MAAAE;AAAA,IACA,OAAO,eAAe,UAAU,eAAe;AAAA,EAAA,CAChD;AACH;AAKO,SAASG,EACdV,GACAO,GACAF,GACW;AACX,SAAOL,EAAO,aAAa;AAAA,IACzB,OAAOK,KAAS;AAAA,IAChB,MAAAE;AAAA,IACA,OAAO,eAAe,WAAW,eAAe;AAAA,EAAA,CACjD;AACH;AAKO,SAASI,EACdX,GACAY,GACAC,GACAC,IAAS,GACH;AACN,EAAAd,EAAO,MAAM,YAAYY,GAAQE,GAAQD,CAAmB;AAC9D;AAKA,eAAsBE,EACpBf,GACAgB,GACAC,GACAV,GACsB;AACtB,QAAMW,IAAiBlB,EAAO,qBAAA;AAC9B,EAAAkB,EAAe,mBAAmBF,GAAc,GAAGC,GAAe,GAAGV,CAAI,GACzEP,EAAO,MAAM,OAAO,CAACkB,EAAe,OAAA,CAAQ,CAAC,GAE7C,MAAMD,EAAc,SAAS,WAAW,IAAI;AAC5C,QAAME,IAAWF,EAAc,eAAA,EAAiB,MAAM,CAAC;AACvD,SAAAA,EAAc,MAAA,GAEPE;AACT;AAKO,SAASC,EAAQb,GAAcc,GAA2B;AAC/D,SAAO,KAAK,KAAKd,IAAOc,CAAS,IAAIA;AACvC;AAKO,SAASC,EAAgBC,GAAqBC,GAA+B;AAClF,SAAO,KAAK,KAAKD,IAAcC,CAAa;AAC9C;ACtNA,MAAAC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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"}