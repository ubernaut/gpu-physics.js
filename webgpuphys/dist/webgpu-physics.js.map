{"version":3,"file":"webgpu-physics.js","sources":["../src/math.js","../src/device.js","../src/shaders/shared.wgsl?raw","../src/shaders/local_to_world.wgsl?raw","../src/shaders/local_to_relative.wgsl?raw","../src/shaders/body_vel_to_particle_vel.wgsl?raw","../src/shaders/clear_grid.wgsl?raw","../src/shaders/build_grid.wgsl?raw","../src/shaders/update_force.wgsl?raw","../src/shaders/update_torque.wgsl?raw","../src/shaders/reduce_force.wgsl?raw","../src/shaders/reduce_torque.wgsl?raw","../src/shaders/update_body_velocity.wgsl?raw","../src/shaders/update_body_angular_velocity.wgsl?raw","../src/shaders/update_body_position.wgsl?raw","../src/shaders/update_body_quaternion.wgsl?raw","../src/world.js","../src/index.js"],"sourcesContent":["/**\n * Math utilities for WebGPU Physics (Vec3, Vec4, Quat, Mat3)\n */\n\nexport class Vec3 {\n  constructor(x = 0, y = 0, z = 0) {\n    this.data = new Float32Array([x, y, z]);\n  }\n\n  get x() { return this.data[0]; }\n  set x(v) { this.data[0] = v; }\n  get y() { return this.data[1]; }\n  set y(v) { this.data[1] = v; }\n  get z() { return this.data[2]; }\n  set z(v) { this.data[2] = v; }\n\n  set(x, y, z) {\n    this.data[0] = x;\n    this.data[1] = y;\n    this.data[2] = z;\n    return this;\n  }\n\n  copy(v) {\n    this.data[0] = v.data[0];\n    this.data[1] = v.data[1];\n    this.data[2] = v.data[2];\n    return this;\n  }\n\n  clone() {\n    return new Vec3(this.x, this.y, this.z);\n  }\n\n  add(v) {\n    this.data[0] += v.data[0];\n    this.data[1] += v.data[1];\n    this.data[2] += v.data[2];\n    return this;\n  }\n\n  sub(v) {\n    this.data[0] -= v.data[0];\n    this.data[1] -= v.data[1];\n    this.data[2] -= v.data[2];\n    return this;\n  }\n\n  scale(s) {\n    this.data[0] *= s;\n    this.data[1] *= s;\n    this.data[2] *= s;\n    return this;\n  }\n\n  dot(v) {\n    return this.data[0] * v.data[0] + this.data[1] * v.data[1] + this.data[2] * v.data[2];\n  }\n\n  cross(v) {\n    const ax = this.data[0], ay = this.data[1], az = this.data[2];\n    const bx = v.data[0], by = v.data[1], bz = v.data[2];\n    this.data[0] = ay * bz - az * by;\n    this.data[1] = az * bx - ax * bz;\n    this.data[2] = ax * by - ay * bx;\n    return this;\n  }\n\n  length() {\n    return Math.sqrt(this.dot(this));\n  }\n\n  lengthSq() {\n    return this.dot(this);\n  }\n\n  normalize() {\n    const len = this.length();\n    if (len > 0) this.scale(1 / len);\n    return this;\n  }\n\n  static cross(a, b, out = new Vec3()) {\n    out.data[0] = a.y * b.z - a.z * b.y;\n    out.data[1] = a.z * b.x - a.x * b.z;\n    out.data[2] = a.x * b.y - a.y * b.x;\n    return out;\n  }\n\n  static dot(a, b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n  }\n}\n\nexport class Vec4 {\n  constructor(x = 0, y = 0, z = 0, w = 0) {\n    this.data = new Float32Array([x, y, z, w]);\n  }\n\n  get x() { return this.data[0]; }\n  set x(v) { this.data[0] = v; }\n  get y() { return this.data[1]; }\n  set y(v) { this.data[1] = v; }\n  get z() { return this.data[2]; }\n  set z(v) { this.data[2] = v; }\n  get w() { return this.data[3]; }\n  set w(v) { this.data[3] = v; }\n\n  set(x, y, z, w) {\n    this.data[0] = x;\n    this.data[1] = y;\n    this.data[2] = z;\n    this.data[3] = w;\n    return this;\n  }\n\n  copy(v) {\n    this.data[0] = v.data[0];\n    this.data[1] = v.data[1];\n    this.data[2] = v.data[2];\n    this.data[3] = v.data[3];\n    return this;\n  }\n\n  clone() {\n    return new Vec4(this.x, this.y, this.z, this.w);\n  }\n}\n\nexport class Quat {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this.data = new Float32Array([x, y, z, w]);\n  }\n\n  get x() { return this.data[0]; }\n  set x(v) { this.data[0] = v; }\n  get y() { return this.data[1]; }\n  set y(v) { this.data[1] = v; }\n  get z() { return this.data[2]; }\n  set z(v) { this.data[2] = v; }\n  get w() { return this.data[3]; }\n  set w(v) { this.data[3] = v; }\n\n  set(x, y, z, w) {\n    this.data[0] = x;\n    this.data[1] = y;\n    this.data[2] = z;\n    this.data[3] = w;\n    return this;\n  }\n\n  copy(q) {\n    this.data[0] = q.data[0];\n    this.data[1] = q.data[1];\n    this.data[2] = q.data[2];\n    this.data[3] = q.data[3];\n    return this;\n  }\n\n  clone() {\n    return new Quat(this.x, this.y, this.z, this.w);\n  }\n\n  identity() {\n    return this.set(0, 0, 0, 1);\n  }\n\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n\n  normalize() {\n    const len = this.length();\n    if (len > 0) {\n      const invLen = 1 / len;\n      this.data[0] *= invLen;\n      this.data[1] *= invLen;\n      this.data[2] *= invLen;\n      this.data[3] *= invLen;\n    }\n    return this;\n  }\n\n  integrate(angularVelocity, dt) {\n    const halfDt = dt * 0.5;\n    const wx = angularVelocity.x;\n    const wy = angularVelocity.y;\n    const wz = angularVelocity.z;\n\n    this.data[0] += halfDt * (wx * this.w + wy * this.z - wz * this.y);\n    this.data[1] += halfDt * (wy * this.w + wz * this.x - wx * this.z);\n    this.data[2] += halfDt * (wz * this.w + wx * this.y - wy * this.x);\n    this.data[3] += halfDt * (-wx * this.x - wy * this.y - wz * this.z);\n\n    return this.normalize();\n  }\n\n  applyToVec3(v, out = new Vec3()) {\n    const x = v.x, y = v.y, z = v.z;\n    const qx = this.x, qy = this.y, qz = this.z, qw = this.w;\n\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n\n    out.data[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out.data[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out.data[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return out;\n  }\n\n  setFromAxisAngle(axis, angle) {\n    const halfAngle = angle * 0.5;\n    const s = Math.sin(halfAngle);\n    this.data[0] = axis.x * s;\n    this.data[1] = axis.y * s;\n    this.data[2] = axis.z * s;\n    this.data[3] = Math.cos(halfAngle);\n    return this;\n  }\n\n  multiply(q) {\n    const ax = this.x, ay = this.y, az = this.z, aw = this.w;\n    const bx = q.x, by = q.y, bz = q.z, bw = q.w;\n\n    this.data[0] = ax * bw + aw * bx + ay * bz - az * by;\n    this.data[1] = ay * bw + aw * by + az * bx - ax * bz;\n    this.data[2] = az * bw + aw * bz + ax * by - ay * bx;\n    this.data[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return this;\n  }\n\n  static slerp(a, b, t, out = new Quat()) {\n    let d = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;\n    let bx = b.x, by = b.y, bz = b.z, bw = b.w;\n    if (d < 0) {\n      bx = -bx; by = -by; bz = -bz; bw = -bw;\n      d = -d;\n    }\n\n    if (d > 0.9995) {\n      out.data[0] = a.x + t * (bx - a.x);\n      out.data[1] = a.y + t * (by - a.y);\n      out.data[2] = a.z + t * (bz - a.z);\n      out.data[3] = a.w + t * (bw - a.w);\n      return out.normalize();\n    }\n\n    const theta0 = Math.acos(d);\n    const theta = theta0 * t;\n    const sinTheta = Math.sin(theta);\n    const sinTheta0 = Math.sin(theta0);\n\n    const s0 = Math.cos(theta) - d * sinTheta / sinTheta0;\n    const s1 = sinTheta / sinTheta0;\n\n    out.data[0] = a.x * s0 + bx * s1;\n    out.data[1] = a.y * s0 + by * s1;\n    out.data[2] = a.z * s0 + bz * s1;\n    out.data[3] = a.w * s0 + bw * s1;\n    return out;\n  }\n}\n\nexport class Mat3 {\n  constructor() {\n    this.data = new Float32Array(9);\n    this.identity();\n  }\n\n  identity() {\n    this.data.fill(0);\n    this.data[0] = 1;\n    this.data[4] = 1;\n    this.data[8] = 1;\n    return this;\n  }\n\n  fromQuat(q) {\n    const x = q.x, y = q.y, z = q.z, w = q.w;\n    const x2 = x + x, y2 = y + y, z2 = z + z;\n    const xx = x * x2, xy = x * y2, xz = x * z2;\n    const yy = y * y2, yz = y * z2, zz = z * z2;\n    const wx = w * x2, wy = w * y2, wz = w * z2;\n\n    // Column-major layout\n    this.data[0] = 1 - (yy + zz);\n    this.data[1] = xy + wz;\n    this.data[2] = xz - wy;\n\n    this.data[3] = xy - wz;\n    this.data[4] = 1 - (xx + zz);\n    this.data[5] = yz + wx;\n\n    this.data[6] = xz + wy;\n    this.data[7] = yz - wx;\n    this.data[8] = 1 - (xx + yy);\n    return this;\n  }\n\n  transpose() {\n    const m = this.data;\n    let tmp;\n    tmp = m[1]; m[1] = m[3]; m[3] = tmp;\n    tmp = m[2]; m[2] = m[6]; m[6] = tmp;\n    tmp = m[5]; m[5] = m[7]; m[7] = tmp;\n    return this;\n  }\n\n  multiply(b) {\n    const a = this.data;\n    const ae = [...a];\n    const be = b.data;\n\n    a[0] = ae[0] * be[0] + ae[3] * be[1] + ae[6] * be[2];\n    a[1] = ae[1] * be[0] + ae[4] * be[1] + ae[7] * be[2];\n    a[2] = ae[2] * be[0] + ae[5] * be[1] + ae[8] * be[2];\n\n    a[3] = ae[0] * be[3] + ae[3] * be[4] + ae[6] * be[5];\n    a[4] = ae[1] * be[3] + ae[4] * be[4] + ae[7] * be[5];\n    a[5] = ae[2] * be[3] + ae[5] * be[4] + ae[8] * be[5];\n\n    a[6] = ae[0] * be[6] + ae[3] * be[7] + ae[6] * be[8];\n    a[7] = ae[1] * be[6] + ae[4] * be[7] + ae[7] * be[8];\n    a[8] = ae[2] * be[6] + ae[5] * be[7] + ae[8] * be[8];\n    return this;\n  }\n\n  applyToVec3(v, out = new Vec3()) {\n    const m = this.data;\n    const x = v.x, y = v.y, z = v.z;\n    out.data[0] = m[0] * x + m[3] * y + m[6] * z;\n    out.data[1] = m[1] * x + m[4] * y + m[7] * z;\n    out.data[2] = m[2] * x + m[5] * y + m[8] * z;\n    return out;\n  }\n\n  setDiagonal(v) {\n    this.data.fill(0);\n    this.data[0] = v.x;\n    this.data[4] = v.y;\n    this.data[8] = v.z;\n    return this;\n  }\n\n  clone() {\n    const m = new Mat3();\n    m.data.set(this.data);\n    return m;\n  }\n}\n\nexport function computeWorldInverseInertia(q, invInertia, out = new Mat3()) {\n  const R = new Mat3().fromQuat(q);\n  const I = new Mat3().setDiagonal(invInertia);\n  const RT = R.clone().transpose();\n\n  // invI_world = R^T * I * R\n  out.data.set(RT.multiply(I).multiply(R).data);\n  return out;\n}\n\nexport function calculateBoxInertia(mass, extents) {\n  const c = (1 / 12) * mass;\n  const ex = 2 * extents.x;\n  const ey = 2 * extents.y;\n  const ez = 2 * extents.z;\n  return new Vec3(\n    c * (ey * ey + ez * ez),\n    c * (ex * ex + ez * ez),\n    c * (ex * ex + ey * ey)\n  );\n}\n\nexport function calculateCloudInertia(mass, particles) {\n  // particles is array of [x,y,z]\n  const particleMass = mass / particles.length;\n  let Ixx = 0, Iyy = 0, Izz = 0;\n  for (const p of particles) {\n    const x = p[0], y = p[1], z = p[2];\n    Ixx += particleMass * (y * y + z * z);\n    Iyy += particleMass * (x * x + z * z);\n    Izz += particleMass * (x * x + y * y);\n  }\n  return new Vec3(Ixx, Iyy, Izz);\n}\n","/**\n * WebGPU device initialization and helper utilities (plain JS + WebGPU)\n */\n\n/**\n * Check if WebGPU is available in the current environment.\n */\nexport function isWebGPUSupported() {\n  return typeof navigator !== 'undefined' && 'gpu' in navigator;\n}\n\n/**\n * Initialize WebGPU and return adapter/device details.\n * Throws if WebGPU is missing or a device cannot be created.\n */\nexport async function initWebGPU() {\n  if (!isWebGPUSupported()) {\n    throw new Error('WebGPU is not supported in this browser. Use Chrome/Edge 113+ with WebGPU enabled.');\n  }\n\n  const gpu = navigator.gpu;\n\n  // Request adapter with high-performance preference.\n  const adapter = await gpu.requestAdapter({ powerPreference: 'high-performance' });\n  if (!adapter) {\n    throw new Error('Failed to acquire a WebGPU adapter. Your GPU may not support WebGPU.');\n  }\n\n  // Log basic adapter info for debugging.\n  const info = adapter.info || {};\n  console.log('WebGPU Adapter:', {\n    vendor: info.vendor,\n    architecture: info.architecture,\n    device: info.device,\n    description: info.description,\n  });\n\n  // Request the device, forwarding the current limits and optional timestamp feature.\n  const requiredFeatures = [];\n  if (adapter.features && adapter.features.has && adapter.features.has('timestamp-query')) {\n    requiredFeatures.push('timestamp-query');\n  }\n\n  const device = await adapter.requestDevice({\n    requiredFeatures,\n    requiredLimits: {\n      maxStorageBufferBindingSize: adapter.limits.maxStorageBufferBindingSize,\n      maxBufferSize: adapter.limits.maxBufferSize,\n      maxComputeWorkgroupsPerDimension: adapter.limits.maxComputeWorkgroupsPerDimension,\n      maxComputeInvocationsPerWorkgroup: adapter.limits.maxComputeInvocationsPerWorkgroup,\n      maxComputeWorkgroupSizeX: adapter.limits.maxComputeWorkgroupSizeX,\n      maxComputeWorkgroupSizeY: adapter.limits.maxComputeWorkgroupSizeY,\n      maxComputeWorkgroupSizeZ: adapter.limits.maxComputeWorkgroupSizeZ,\n    },\n  });\n\n  // Device loss handling.\n  device.lost.then((lossInfo) => {\n    console.error('WebGPU device lost:', lossInfo.message);\n    if (lossInfo.reason !== 'destroyed') {\n      console.error('Device loss reason:', lossInfo.reason);\n    }\n  });\n\n  // Uncaptured error hook.\n  device.onuncapturederror = (event) => {\n    console.error('WebGPU uncaptured error:', event.error);\n  };\n\n  return {\n    adapter,\n    device,\n    features: device.features,\n    limits: device.limits,\n  };\n}\n\n/**\n * Create a shader module from WGSL source.\n */\nexport function createShaderModule(device, code, label) {\n  return device.createShaderModule({\n    label: label || 'shader',\n    code,\n  });\n}\n\n/**\n * Create a compute pipeline.\n */\nexport function createComputePipeline(device, shaderModule, entryPoint, layout, label) {\n  return device.createComputePipeline({\n    label: label || 'compute-pipeline',\n    layout,\n    compute: {\n      module: shaderModule,\n      entryPoint,\n    },\n  });\n}\n\n/**\n * Create a storage buffer.\n */\nexport function createStorageBuffer(device, size, label, mappedAtCreation = false) {\n  return device.createBuffer({\n    label: label || 'storage-buffer',\n    size,\n    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n    mappedAtCreation,\n  });\n}\n\n/**\n * Create a uniform buffer.\n */\nexport function createUniformBuffer(device, size, label) {\n  return device.createBuffer({\n    label: label || 'uniform-buffer',\n    size,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n}\n\n/**\n * Create a staging buffer for GPU -> CPU readback.\n */\nexport function createStagingBuffer(device, size, label) {\n  return device.createBuffer({\n    label: label || 'staging-buffer',\n    size,\n    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n  });\n}\n\n/**\n * Write data to a buffer.\n */\nexport function writeBuffer(device, buffer, data, offset = 0) {\n  device.queue.writeBuffer(buffer, offset, data);\n}\n\n/**\n * Read data from a buffer asynchronously using a staging buffer.\n */\nexport async function readBuffer(device, sourceBuffer, stagingBuffer, size) {\n  const commandEncoder = device.createCommandEncoder();\n  commandEncoder.copyBufferToBuffer(sourceBuffer, 0, stagingBuffer, 0, size);\n  device.queue.submit([commandEncoder.finish()]);\n\n  await stagingBuffer.mapAsync(GPUMapMode.READ);\n  const copyData = stagingBuffer.getMappedRange().slice(0);\n  stagingBuffer.unmap();\n  return copyData;\n}\n\n/**\n * Align a size to the next multiple of alignment.\n */\nexport function alignTo(size, alignment) {\n  return Math.ceil(size / alignment) * alignment;\n}\n\n/**\n * Compute workgroup dispatch size for a given element count.\n */\nexport function getDispatchSize(numElements, workgroupSize) {\n  return Math.ceil(numElements / workgroupSize);\n}\n","export default \"// Shared WGSL utilities for WebGPU Physics\\n\\n// Simulation parameters uniform buffer\\nstruct Params {\\n  // params1: stiffness, damping, radius, particleCount\\n  stiffness: f32,\\n  damping: f32,\\n  radius: f32,\\n  particleCount: f32,\\n  \\n  // params2: dt, friction, drag, bodyCount  \\n  dt: f32,\\n  friction: f32,\\n  drag: f32,\\n  bodyCount: f32,\\n  \\n  // gravity: x, y, z, 0\\n  gravity: vec4<f32>,\\n  \\n  // boxSize: x, y, z, 0\\n  boxSize: vec4<f32>,\\n  \\n  // gridPos: x, y, z, 0\\n  gridPos: vec4<f32>,\\n  \\n  // gridRes: x, y, z, maxParticlesPerCell\\n  gridRes: vec4<f32>,\\n  \\n  // sphereInteraction: x, y, z, radius\\n  sphere: vec4<f32>,\\n  \\n  // maxVelocity: x, y, z, 0\\n  maxVelocity: vec4<f32>,\\n}\\n\\n// Workgroup size constant\\nconst WORKGROUP_SIZE: u32 = 64u;\\n\\n// Get grid cell position from world position\\nfn worldPosToGridPos(particlePos: vec3<f32>, gridPos: vec3<f32>, cellSize: vec3<f32>) -> vec3<i32> {\\n  return vec3<i32>(floor((particlePos - gridPos) / cellSize));\\n}\\n\\n// Convert 3D grid position to linear index\\nfn gridPosToIndex(gridPos: vec3<i32>, gridRes: vec3<i32>) -> i32 {\\n  // Clamp to valid range\\n  let clamped = clamp(gridPos, vec3<i32>(0), gridRes - vec3<i32>(1));\\n  return clamped.x + clamped.y * gridRes.x + clamped.z * gridRes.x * gridRes.y;\\n}\\n\\n// Check if grid position is valid\\nfn isValidGridPos(gridPos: vec3<i32>, gridRes: vec3<i32>) -> bool {\\n  return gridPos.x >= 0 && gridPos.x < gridRes.x &&\\n         gridPos.y >= 0 && gridPos.y < gridRes.y &&\\n         gridPos.z >= 0 && gridPos.z < gridRes.z;\\n}\\n\\n// Quaternion multiplication\\nfn quatMul(a: vec4<f32>, b: vec4<f32>) -> vec4<f32> {\\n  return vec4<f32>(\\n    a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,\\n    a.w * b.y + a.y * b.w + a.z * b.x - a.x * b.z,\\n    a.w * b.z + a.z * b.w + a.x * b.y - a.y * b.x,\\n    a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z\\n  );\\n}\\n\\n// Integrate quaternion with angular velocity\\nfn quatIntegrate(q: vec4<f32>, w: vec3<f32>, dt: f32) -> vec4<f32> {\\n  let halfDt = dt * 0.5;\\n  \\n  var result = q;\\n  result.x += halfDt * (w.x * q.w + w.y * q.z - w.z * q.y);\\n  result.y += halfDt * (w.y * q.w + w.z * q.x - w.x * q.z);\\n  result.z += halfDt * (w.z * q.w + w.x * q.y - w.y * q.x);\\n  result.w += halfDt * (-w.x * q.x - w.y * q.y - w.z * q.z);\\n  \\n  return normalize(result);\\n}\\n\\n// Rotate vector by quaternion\\nfn quatRotate(v: vec3<f32>, q: vec4<f32>) -> vec3<f32> {\\n  let ix = q.w * v.x + q.y * v.z - q.z * v.y;\\n  let iy = q.w * v.y + q.z * v.x - q.x * v.z;\\n  let iz = q.w * v.z + q.x * v.y - q.y * v.x;\\n  let iw = -q.x * v.x - q.y * v.y - q.z * v.z;\\n  \\n  return vec3<f32>(\\n    ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y,\\n    iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z,\\n    iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x\\n  );\\n}\\n\\n// Quaternion to rotation matrix (3x3)\\nfn quatToMat3(q: vec4<f32>) -> mat3x3<f32> {\\n  let x = q.x;\\n  let y = q.y;\\n  let z = q.z;\\n  let w = q.w;\\n  \\n  let x2 = x + x;\\n  let y2 = y + y;\\n  let z2 = z + z;\\n  \\n  let xx = x * x2;\\n  let xy = x * y2;\\n  let xz = x * z2;\\n  let yy = y * y2;\\n  let yz = y * z2;\\n  let zz = z * z2;\\n  let wx = w * x2;\\n  let wy = w * y2;\\n  let wz = w * z2;\\n  \\n  return mat3x3<f32>(\\n    vec3<f32>(1.0 - (yy + zz), xy + wz, xz - wy),\\n    vec3<f32>(xy - wz, 1.0 - (xx + zz), yz + wx),\\n    vec3<f32>(xz + wy, yz - wx, 1.0 - (xx + yy))\\n  );\\n}\\n\\n// Compute world-space inverse inertia tensor\\nfn invInertiaWorld(q: vec4<f32>, invInertia: vec3<f32>) -> mat3x3<f32> {\\n  let R = quatToMat3(q);\\n  let RT = transpose(R);\\n  \\n  // Diagonal inverse inertia matrix\\n  let I = mat3x3<f32>(\\n    vec3<f32>(invInertia.x, 0.0, 0.0),\\n    vec3<f32>(0.0, invInertia.y, 0.0),\\n    vec3<f32>(0.0, 0.0, invInertia.z)\\n  );\\n  \\n  // R^T * I * R\\n  return RT * I * R;\\n}\\n\\n// Cross product\\nfn cross3(a: vec3<f32>, b: vec3<f32>) -> vec3<f32> {\\n  return vec3<f32>(\\n    a.y * b.z - a.z * b.y,\\n    a.z * b.x - a.x * b.z,\\n    a.x * b.y - a.y * b.x\\n  );\\n}\\n\\n// Particle contact force calculation (spring-damper model)\\nfn particleForce(\\n  stiffness: f32,\\n  damping: f32,\\n  friction: f32,\\n  distance: f32,\\n  minDistance: f32,\\n  xi: vec3<f32>,\\n  xj: vec3<f32>,\\n  vi: vec3<f32>,\\n  vj: vec3<f32>\\n) -> vec3<f32> {\\n  let rij = xj - xi;\\n  let len = length(rij);\\n  \\n  if (len < 0.0001) {\\n    return vec3<f32>(0.0);\\n  }\\n  \\n  let rijUnit = rij / len;\\n  let vij = vj - vi;\\n  let vijT = vij - dot(vij, rijUnit) * rijUnit;\\n  \\n  let springForce = -stiffness * (distance - max(len, minDistance)) * rijUnit;\\n  let dampingForce = damping * dot(vij, rijUnit) * rijUnit;\\n  let tangentForce = friction * vijT;\\n  \\n  return springForce + dampingForce + tangentForce;\\n}\\n\"","export default \"// Transform local particle positions to world space\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleLocalPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyPos: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> bodyQuat: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read_write> particleWorldPos: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let localPosAndBodyId = particleLocalPos[particleIndex];\\n  let localPos = localPosAndBodyId.xyz;\\n  let bodyId = u32(localPosAndBodyId.w);\\n  \\n  let bodyPosition = bodyPos[bodyId].xyz;\\n  let bodyQuaternion = bodyQuat[bodyId];\\n  \\n  // Rotate local position by body quaternion and add body position\\n  let worldPos = bodyPosition + quatRotate(localPos, bodyQuaternion);\\n  \\n  particleWorldPos[particleIndex] = vec4<f32>(worldPos, f32(bodyId));\\n}\\n\"","export default \"// Compute relative particle positions (for torque calculation)\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleLocalPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyPos: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> bodyQuat: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read_write> particleRelativePos: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let localPosAndBodyId = particleLocalPos[particleIndex];\\n  let localPos = localPosAndBodyId.xyz;\\n  let bodyId = u32(localPosAndBodyId.w);\\n  \\n  let bodyQuaternion = bodyQuat[bodyId];\\n  \\n  // Relative position = rotated local position (without body position offset)\\n  let relativePos = quatRotate(localPos, bodyQuaternion);\\n  \\n  particleRelativePos[particleIndex] = vec4<f32>(relativePos, f32(bodyId));\\n}\\n\"","export default \"// Derive particle velocities from body velocities\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleRelativePos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyVel: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> bodyAngularVel: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read_write> particleVel: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let relativePosAndBodyId = particleRelativePos[particleIndex];\\n  let relativePos = relativePosAndBodyId.xyz;\\n  let bodyId = u32(relativePosAndBodyId.w);\\n  \\n  let linearVel = bodyVel[bodyId].xyz;\\n  let angularVel = bodyAngularVel[bodyId].xyz;\\n  \\n  // v_particle = v_body + omega x r\\n  let vel = linearVel + cross3(angularVel, relativePos);\\n  \\n  particleVel[particleIndex] = vec4<f32>(vel, 1.0);\\n}\\n\"","export default \"// Clear the spatial hash grid\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read_write> gridCellCount: array<atomic<u32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  // Calculate linear index from 2D dispatch to support > 65535 workgroups\\n  // stride (dispatchX * WORKGROUP_SIZE) is stored in params.maxVelocity.w\\n  let stride = u32(params.maxVelocity.w);\\n  let cellIndex = id.y * stride + id.x;\\n  \\n  let gridRes = vec3<i32>(params.gridRes.xyz);\\n  let totalCells = u32(gridRes.x * gridRes.y * gridRes.z);\\n  \\n  if (cellIndex >= totalCells) {\\n    return;\\n  }\\n  \\n  atomicStore(&gridCellCount[cellIndex], 0u);\\n}\\n\"","export default \"// Build spatial hash grid from particle positions\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleWorldPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read_write> gridCellCount: array<atomic<u32>>;\\n@group(0) @binding(3) var<storage, read_write> gridCellParticles: array<u32>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let worldPos = particleWorldPos[particleIndex].xyz;\\n  let cellSize = vec3<f32>(params.radius * 2.0);\\n  let gridPos = params.gridPos.xyz;\\n  let gridRes = vec3<i32>(params.gridRes.xyz);\\n  let maxParticlesPerCell = u32(params.gridRes.w);\\n  \\n  // Get grid cell for this particle\\n  let cellPos = worldPosToGridPos(worldPos, gridPos, cellSize);\\n  \\n  // Check if within grid bounds\\n  if (!isValidGridPos(cellPos, gridRes)) {\\n    return;\\n  }\\n  \\n  let cellIndex = gridPosToIndex(cellPos, gridRes);\\n  \\n  // Atomically increment cell count and get slot\\n  let slot = atomicAdd(&gridCellCount[u32(cellIndex)], 1u);\\n  \\n  // Store particle index if slot available\\n  if (slot < maxParticlesPerCell) {\\n    let particleSlotIndex = u32(cellIndex) * maxParticlesPerCell + slot;\\n    gridCellParticles[particleSlotIndex] = particleIndex + 1u; // Store +1 so 0 means empty\\n  }\\n}\\n\"","export default \"// Calculate particle collision forces\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleWorldPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> particleRelativePos: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> particleVel: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read> bodyAngularVel: array<vec4<f32>>;\\n@group(0) @binding(5) var<storage, read> gridCellCount: array<u32>;\\n@group(0) @binding(6) var<storage, read> gridCellParticles: array<u32>;\\n@group(0) @binding(7) var<storage, read_write> particleForceOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let worldPosAndBodyId = particleWorldPos[particleIndex];\\n  let position = worldPosAndBodyId.xyz;\\n  let bodyId = u32(worldPosAndBodyId.w);\\n  \\n  let velocity = particleVel[particleIndex].xyz;\\n  let relativePos = particleRelativePos[particleIndex].xyz;\\n  let angularVel = bodyAngularVel[bodyId].xyz;\\n  \\n  let cellSize = vec3<f32>(params.radius * 2.0);\\n  let gridPos = params.gridPos.xyz;\\n  let gridRes = vec3<i32>(params.gridRes.xyz);\\n  let maxParticlesPerCell = u32(params.gridRes.w);\\n  let radius = params.radius;\\n  let stiffness = params.stiffness;\\n  let damping = params.damping;\\n  let friction = params.friction;\\n  \\n  var force = vec3<f32>(0.0);\\n  \\n  // Get current particle's grid cell\\n  let particleGridPos = worldPosToGridPos(position, gridPos, cellSize);\\n  \\n  // Check neighboring cells (3x3x3)\\n  for (var i = -1; i <= 1; i++) {\\n    for (var j = -1; j <= 1; j++) {\\n      for (var k = -1; k <= 1; k++) {\\n        let neighborCellPos = particleGridPos + vec3<i32>(i, j, k);\\n        \\n        if (!isValidGridPos(neighborCellPos, gridRes)) {\\n          continue;\\n        }\\n        \\n        let cellIndex = gridPosToIndex(neighborCellPos, gridRes);\\n        \\n        // Check all particles in this cell\\n        for (var slot = 0u; slot < maxParticlesPerCell; slot++) {\\n          let particleSlotIndex = u32(cellIndex) * maxParticlesPerCell + slot;\\n          let neighborIndexPlusOne = gridCellParticles[particleSlotIndex];\\n          \\n          if (neighborIndexPlusOne == 0u) {\\n            continue; // Empty slot\\n          }\\n          \\n          let neighborIndex = neighborIndexPlusOne - 1u;\\n          \\n          if (neighborIndex == particleIndex) {\\n            continue; // Skip self\\n          }\\n          \\n          let neighborPosAndBodyId = particleWorldPos[neighborIndex];\\n          let neighborPos = neighborPosAndBodyId.xyz;\\n          let neighborBodyId = u32(neighborPosAndBodyId.w);\\n          \\n          if (neighborBodyId == bodyId) {\\n            continue; // Skip same body\\n          }\\n          \\n          let neighborVel = particleVel[neighborIndex].xyz;\\n          let neighborRelativePos = particleRelativePos[neighborIndex].xyz;\\n          let neighborAngularVel = bodyAngularVel[neighborBodyId].xyz;\\n          \\n          // Check collision\\n          let r = position - neighborPos;\\n          let dist = length(r);\\n          \\n          if (dist > 0.0 && dist < radius * 2.0) {\\n            let dir = normalize(r);\\n            \\n            // Compute velocities including angular contribution\\n            let v = velocity - cross3(relativePos + radius * dir, angularVel);\\n            let nv = neighborVel - cross3(neighborRelativePos + radius * (-dir), neighborAngularVel);\\n            \\n            force += particleForce(stiffness, damping, friction, 2.0 * radius, radius, position, neighborPos, v, nv);\\n          }\\n        }\\n      }\\n    }\\n  }\\n  \\n  // Ground/boundary collisions\\n  let boxMin = vec3<f32>(-params.boxSize.x, 0.0, -params.boxSize.z);\\n  let boxMax = vec3<f32>(params.boxSize.x, params.boxSize.y * 0.5, params.boxSize.z);\\n  \\n  // X bounds\\n  {\\n    let dir = vec3<f32>(1.0, 0.0, 0.0);\\n    let v = velocity - cross3(relativePos + radius * dir, angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let x = position.x - radius;\\n    if (x < boxMin.x) {\\n      force += -(stiffness * (x - boxMin.x) * dir + damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  {\\n    let dir = vec3<f32>(-1.0, 0.0, 0.0);\\n    let v = velocity - cross3(relativePos + radius * (-dir), angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let x = position.x + radius;\\n    if (x > boxMax.x) {\\n      force -= -(stiffness * (x - boxMax.x) * dir - damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  \\n  // Y bounds (ground)\\n  {\\n    let dir = vec3<f32>(0.0, 1.0, 0.0);\\n    let v = velocity - cross3(relativePos + radius * dir, angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let y = position.y - radius;\\n    if (y < boxMin.y) {\\n      force += -(stiffness * (y - boxMin.y) * dir + damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  {\\n    let dir = vec3<f32>(0.0, -1.0, 0.0);\\n    let v = velocity - cross3(relativePos + radius * (-dir), angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let y = position.y + radius;\\n    if (y > boxMax.y) {\\n      force -= -(stiffness * (y - boxMax.y) * dir - damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  \\n  // Z bounds\\n  {\\n    let dir = vec3<f32>(0.0, 0.0, 1.0);\\n    let v = velocity - cross3(relativePos + radius * dir, angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let z = position.z - radius;\\n    if (z < boxMin.z) {\\n      force += -(stiffness * (z - boxMin.z) * dir + damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  {\\n    let dir = vec3<f32>(0.0, 0.0, -1.0);\\n    let v = velocity - cross3(relativePos + radius * (-dir), angularVel);\\n    let tangentVel = v - dot(v, dir) * dir;\\n    let z = position.z + radius;\\n    if (z > boxMax.z) {\\n      force -= -(stiffness * (z - boxMax.z) * dir - damping * dot(v, dir) * dir);\\n      force -= friction * tangentVel;\\n    }\\n  }\\n  \\n  // Interaction sphere collision\\n  let spherePos = params.sphere.xyz;\\n  let sphereRadius = params.sphere.w;\\n  let rSphere = position - spherePos;\\n  let distSphere = length(rSphere);\\n  if (distSphere > 0.0 && distSphere < sphereRadius + radius) {\\n    force += particleForce(stiffness, damping, friction, radius + sphereRadius, sphereRadius, position, spherePos, velocity, vec3<f32>(0.0));\\n  }\\n  \\n  particleForceOut[particleIndex] = vec4<f32>(force, 1.0);\\n}\\n\"","export default \"// Calculate particle collision torques (similar to force but for rotation)\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleWorldPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> particleRelativePos: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> particleVel: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read> bodyAngularVel: array<vec4<f32>>;\\n@group(0) @binding(5) var<storage, read> gridCellCount: array<u32>;\\n@group(0) @binding(6) var<storage, read> gridCellParticles: array<u32>;\\n@group(0) @binding(7) var<storage, read_write> particleTorqueOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let worldPosAndBodyId = particleWorldPos[particleIndex];\\n  let position = worldPosAndBodyId.xyz;\\n  let bodyId = u32(worldPosAndBodyId.w);\\n  \\n  let velocity = particleVel[particleIndex].xyz;\\n  let relativePos = particleRelativePos[particleIndex].xyz;\\n  let angularVel = bodyAngularVel[bodyId].xyz;\\n  \\n  let cellSize = vec3<f32>(params.radius * 2.0);\\n  let gridPos = params.gridPos.xyz;\\n  let gridRes = vec3<i32>(params.gridRes.xyz);\\n  let maxParticlesPerCell = u32(params.gridRes.w);\\n  let radius = params.radius;\\n  let stiffness = params.stiffness;\\n  let damping = params.damping;\\n  let friction = params.friction;\\n  \\n  var torque = vec3<f32>(0.0);\\n  \\n  // Get current particle's grid cell\\n  let particleGridPos = worldPosToGridPos(position, gridPos, cellSize);\\n  \\n  // Check neighboring cells (3x3x3) - same logic as update_force\\n  for (var i = -1; i <= 1; i++) {\\n    for (var j = -1; j <= 1; j++) {\\n      for (var k = -1; k <= 1; k++) {\\n        let neighborCellPos = particleGridPos + vec3<i32>(i, j, k);\\n        \\n        if (!isValidGridPos(neighborCellPos, gridRes)) {\\n          continue;\\n        }\\n        \\n        let cellIndex = gridPosToIndex(neighborCellPos, gridRes);\\n        \\n        for (var slot = 0u; slot < maxParticlesPerCell; slot++) {\\n          let particleSlotIndex = u32(cellIndex) * maxParticlesPerCell + slot;\\n          let neighborIndexPlusOne = gridCellParticles[particleSlotIndex];\\n          \\n          if (neighborIndexPlusOne == 0u) {\\n            continue;\\n          }\\n          \\n          let neighborIndex = neighborIndexPlusOne - 1u;\\n          \\n          if (neighborIndex == particleIndex) {\\n            continue;\\n          }\\n          \\n          let neighborPosAndBodyId = particleWorldPos[neighborIndex];\\n          let neighborPos = neighborPosAndBodyId.xyz;\\n          let neighborBodyId = u32(neighborPosAndBodyId.w);\\n          \\n          if (neighborBodyId == bodyId) {\\n            continue;\\n          }\\n          \\n          let neighborVel = particleVel[neighborIndex].xyz;\\n          let neighborRelativePos = particleRelativePos[neighborIndex].xyz;\\n          let neighborAngularVel = bodyAngularVel[neighborBodyId].xyz;\\n          \\n          let r = position - neighborPos;\\n          let dist = length(r);\\n          \\n          if (dist > 0.0 && dist < radius * 2.0) {\\n            let dir = normalize(r);\\n            let v = velocity - cross3(relativePos + radius * dir, angularVel);\\n            let nv = neighborVel - cross3(neighborRelativePos + radius * (-dir), neighborAngularVel);\\n            \\n            let force = particleForce(stiffness, damping, friction, 2.0 * radius, radius, position, neighborPos, v, nv);\\n            \\n            // Torque = r x F (relative position cross force)\\n            torque += cross3(relativePos, force);\\n          }\\n        }\\n      }\\n    }\\n  }\\n  \\n  particleTorqueOut[particleIndex] = vec4<f32>(torque, 1.0);\\n}\\n\"","export default \"// Reduce particle forces to body forces using atomics\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleLocalPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> particleForceBuf: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read_write> bodyForce: array<atomic<u32>>;\\n\\n// Helper to atomic add f32 by encoding as u32\\nfn atomicAddF32(ptr: ptr<storage, atomic<u32>, read_write>, value: f32) {\\n  var old = atomicLoad(ptr);\\n  loop {\\n    let newVal = bitcast<u32>(bitcast<f32>(old) + value);\\n    let result = atomicCompareExchangeWeak(ptr, old, newVal);\\n    if (result.exchanged) {\\n      break;\\n    }\\n    old = result.old_value;\\n  }\\n}\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let localPosAndBodyId = particleLocalPos[particleIndex];\\n  let bodyId = u32(localPosAndBodyId.w);\\n  \\n  let force = particleForceBuf[particleIndex].xyz;\\n  \\n  // Atomic add force components to body\\n  // Body force is stored as 4 u32s: (fx, fy, fz, 1) encoded as f32->u32\\n  let bodyOffset = bodyId * 4u;\\n  \\n  atomicAddF32(&bodyForce[bodyOffset + 0u], force.x);\\n  atomicAddF32(&bodyForce[bodyOffset + 1u], force.y);\\n  atomicAddF32(&bodyForce[bodyOffset + 2u], force.z);\\n}\\n\"","export default \"// Reduce particle torques to body torques using atomics\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> particleLocalPos: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> particleRelativePos: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> particleForceBuf: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read> particleTorque: array<vec4<f32>>;\\n@group(0) @binding(5) var<storage, read_write> bodyTorque: array<atomic<u32>>;\\n\\n// Helper to atomic add f32 by encoding as u32\\nfn atomicAddF32Torque(ptr: ptr<storage, atomic<u32>, read_write>, value: f32) {\\n  var old = atomicLoad(ptr);\\n  loop {\\n    let newVal = bitcast<u32>(bitcast<f32>(old) + value);\\n    let result = atomicCompareExchangeWeak(ptr, old, newVal);\\n    if (result.exchanged) {\\n      break;\\n    }\\n    old = result.old_value;\\n  }\\n}\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let particleIndex = id.x;\\n  \\n  if (particleIndex >= u32(params.particleCount)) {\\n    return;\\n  }\\n  \\n  let localPosAndBodyId = particleLocalPos[particleIndex];\\n  let bodyId = u32(localPosAndBodyId.w);\\n  \\n  let relativePos = particleRelativePos[particleIndex].xyz;\\n  let force = particleForceBuf[particleIndex].xyz;\\n  let torqueFromCollision = particleTorque[particleIndex].xyz;\\n  \\n  // Total torque = collision torque + r x F\\n  let totalTorque = torqueFromCollision + cross3(relativePos, force);\\n  \\n  // Atomic add torque components to body\\n  let bodyOffset = bodyId * 4u;\\n  \\n  atomicAddF32Torque(&bodyTorque[bodyOffset + 0u], totalTorque.x);\\n  atomicAddF32Torque(&bodyTorque[bodyOffset + 1u], totalTorque.y);\\n  atomicAddF32Torque(&bodyTorque[bodyOffset + 2u], totalTorque.z);\\n}\\n\"","export default \"// Update body linear velocity\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> bodyVelIn: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyForce: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> bodyMass: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read_write> bodyVelOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let bodyIndex = id.x;\\n  \\n  if (bodyIndex >= u32(params.bodyCount)) {\\n    return;\\n  }\\n  \\n  let velocity = bodyVelIn[bodyIndex].xyz;\\n  let force = bodyForce[bodyIndex].xyz;\\n  let massData = bodyMass[bodyIndex];\\n  let invMass = massData.w; // Inverse mass stored in w component\\n  \\n  let dt = params.dt;\\n  let gravity = params.gravity.xyz;\\n  let drag = params.drag;\\n  let maxVel = params.maxVelocity.xyz;\\n  \\n  // Skip static bodies (invMass == 0)\\n  if (invMass == 0.0) {\\n    bodyVelOut[bodyIndex] = vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n    return;\\n  }\\n  \\n  // Apply gravity and forces: v += (g + F/m) * dt\\n  var newVel = velocity + (gravity + force * invMass) * dt;\\n  \\n  // Apply drag\\n  newVel = newVel * (1.0 - drag * dt);\\n  \\n  // Clamp velocity\\n  newVel = clamp(newVel, -maxVel, maxVel);\\n  \\n  bodyVelOut[bodyIndex] = vec4<f32>(newVel, 1.0);\\n}\\n\"","export default \"// Update body angular velocity\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> bodyAngVelIn: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyTorque: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read> bodyMass: array<vec4<f32>>;\\n@group(0) @binding(4) var<storage, read> bodyQuat: array<vec4<f32>>;\\n@group(0) @binding(5) var<storage, read_write> bodyAngVelOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let bodyIndex = id.x;\\n  \\n  if (bodyIndex >= u32(params.bodyCount)) {\\n    return;\\n  }\\n  \\n  let angularVel = bodyAngVelIn[bodyIndex].xyz;\\n  let torque = bodyTorque[bodyIndex].xyz;\\n  let massData = bodyMass[bodyIndex];\\n  let invInertia = massData.xyz; // Inverse inertia stored in xyz\\n  let invMass = massData.w;\\n  let quat = bodyQuat[bodyIndex];\\n  \\n  let dt = params.dt;\\n  let drag = params.drag;\\n  let maxVel = params.maxVelocity.xyz;\\n  \\n  // Skip static bodies\\n  if (invMass == 0.0) {\\n    bodyAngVelOut[bodyIndex] = vec4<f32>(0.0, 0.0, 0.0, 1.0);\\n    return;\\n  }\\n  \\n  // Compute world-space inverse inertia tensor\\n  let invIWorld = invInertiaWorld(quat, invInertia);\\n  \\n  // Apply torque: omega += I^-1 * T * dt\\n  let angularAccel = invIWorld * torque;\\n  var newAngVel = angularVel + angularAccel * dt;\\n  \\n  // Apply drag\\n  newAngVel = newAngVel * (1.0 - drag * dt);\\n  \\n  // Clamp angular velocity\\n  newAngVel = clamp(newAngVel, -maxVel, maxVel);\\n  \\n  bodyAngVelOut[bodyIndex] = vec4<f32>(newAngVel, 1.0);\\n}\\n\"","export default \"// Update body position\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> bodyPosIn: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyVel: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read_write> bodyPosOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let bodyIndex = id.x;\\n  \\n  if (bodyIndex >= u32(params.bodyCount)) {\\n    return;\\n  }\\n  \\n  let position = bodyPosIn[bodyIndex].xyz;\\n  let velocity = bodyVel[bodyIndex].xyz;\\n  let dt = params.dt;\\n  \\n  // Simple Euler integration: x += v * dt\\n  let newPos = position + velocity * dt;\\n  \\n  bodyPosOut[bodyIndex] = vec4<f32>(newPos, 1.0);\\n}\\n\"","export default \"// Update body quaternion\\n\\n@group(0) @binding(0) var<uniform> params: Params;\\n@group(0) @binding(1) var<storage, read> bodyQuatIn: array<vec4<f32>>;\\n@group(0) @binding(2) var<storage, read> bodyAngVel: array<vec4<f32>>;\\n@group(0) @binding(3) var<storage, read_write> bodyQuatOut: array<vec4<f32>>;\\n\\n@compute @workgroup_size(WORKGROUP_SIZE)\\nfn main(@builtin(global_invocation_id) id: vec3<u32>) {\\n  let bodyIndex = id.x;\\n  \\n  if (bodyIndex >= u32(params.bodyCount)) {\\n    return;\\n  }\\n  \\n  let quat = bodyQuatIn[bodyIndex];\\n  let angularVel = bodyAngVel[bodyIndex].xyz;\\n  let dt = params.dt;\\n  \\n  // Integrate quaternion with angular velocity\\n  let newQuat = quatIntegrate(quat, angularVel, dt);\\n  \\n  bodyQuatOut[bodyIndex] = newQuat;\\n}\\n\"","import { Vec3 } from \"./math.js\";\nimport {\n  initWebGPU,\n  createShaderModule,\n  createStorageBuffer,\n  createUniformBuffer,\n  createStagingBuffer,\n  writeBuffer,\n  readBuffer,\n  getDispatchSize,\n  alignTo\n} from \"./device.js\";\nimport sharedWgsl from \"./shaders/shared.wgsl?raw\";\nimport localToWorldWgsl from \"./shaders/local_to_world.wgsl?raw\";\nimport localToRelativeWgsl from \"./shaders/local_to_relative.wgsl?raw\";\nimport bodyVelToParticleVelWgsl from \"./shaders/body_vel_to_particle_vel.wgsl?raw\";\nimport clearGridWgsl from \"./shaders/clear_grid.wgsl?raw\";\nimport buildGridWgsl from \"./shaders/build_grid.wgsl?raw\";\nimport updateForceWgsl from \"./shaders/update_force.wgsl?raw\";\nimport updateTorqueWgsl from \"./shaders/update_torque.wgsl?raw\";\nimport reduceForceWgsl from \"./shaders/reduce_force.wgsl?raw\";\nimport reduceTorqueWgsl from \"./shaders/reduce_torque.wgsl?raw\";\nimport updateBodyVelocityWgsl from \"./shaders/update_body_velocity.wgsl?raw\";\nimport updateBodyAngularVelocityWgsl from \"./shaders/update_body_angular_velocity.wgsl?raw\";\nimport updateBodyPositionWgsl from \"./shaders/update_body_position.wgsl?raw\";\nimport updateBodyQuaternionWgsl from \"./shaders/update_body_quaternion.wgsl?raw\";\nconst WORKGROUP_SIZE = 64;\nconst MAX_PARTICLES_PER_CELL = 4;\nclass World {\n  // WebGPU context\n  ctx;\n  device;\n  // Buffers\n  buffers;\n  pipelines;\n  layouts;\n  bindGroups = /* @__PURE__ */ new Map();\n  // Simulation state\n  _bodyCount = 0;\n  _particleCount = 0;\n  maxBodies;\n  maxParticles;\n  // Simulation parameters\n  params;\n  grid;\n  // Timing\n  time = 0;\n  fixedTime = 0;\n  accumulator = 0;\n  maxSubSteps;\n  _interpolationValue = 0;\n  // Double-buffer state (which buffer is current)\n  bufferIndex = 0;\n  // CPU-side data for initialization\n  bodyPositions;\n  bodyQuaternions;\n  bodyMasses;\n  particleLocalPositions;\n  // Dirty flags for CPU->GPU sync\n  bodyDataDirty = true;\n  particleDataDirty = true;\n  massDirty = true;\n  // Sphere interaction\n  interactionSphere = {\n    position: new Vec3(10, 1, 0),\n    radius: 1\n  };\n  // Initialization promise\n  initPromise;\n  initialized = false;\n  constructor(options = {}) {\n    this.maxBodies = options.maxBodies || 64;\n    this.maxParticles = options.maxParticles || 256;\n    this.maxSubSteps = options.maxSubSteps || 5;\n    this.params = {\n      stiffness: options.stiffness ?? 1700,\n      damping: options.damping ?? 6,\n      friction: options.friction ?? 2,\n      drag: options.drag ?? 0.1,\n      radius: options.radius ?? 0.5,\n      fixedTimeStep: options.fixedTimeStep ?? 1 / 120,\n      gravity: options.gravity?.data ?? new Float32Array([0, -9.81, 0]),\n      boxSize: options.boxSize?.data ?? new Float32Array([10, 10, 10])\n    };\n    const gridRes = options.gridResolution || new Vec3(64, 64, 64);\n    this.grid = {\n      position: options.gridPosition?.data ?? new Float32Array([0, 0, 0]),\n      resolution: gridRes.data,\n      maxParticlesPerCell: MAX_PARTICLES_PER_CELL\n    };\n    this.bodyPositions = new Float32Array(this.maxBodies * 4);\n    this.bodyQuaternions = new Float32Array(this.maxBodies * 4);\n    this.bodyMasses = new Float32Array(this.maxBodies * 4);\n    this.particleLocalPositions = new Float32Array(this.maxParticles * 4);\n    for (let i = 0; i < this.maxBodies; i++) {\n      this.bodyQuaternions[i * 4 + 3] = 1;\n    }\n    this.initPromise = this.initialize();\n  }\n  /**\n   * Initialize WebGPU resources\n   */\n  async initialize() {\n    this.ctx = await initWebGPU();\n    this.device = this.ctx.device;\n    this.createBuffers();\n    await this.createPipelines();\n    this.createBindGroups();\n    this.initialized = true;\n  }\n  /**\n   * Wait for initialization to complete\n   */\n  async ready() {\n    await this.initPromise;\n  }\n  /**\n   * Create all GPU buffers\n   */\n  createBuffers() {\n    const device = this.device;\n    const bodySize = this.maxBodies * 4 * 4;\n    const particleSize = this.maxParticles * 4 * 4;\n    const gridCellCount = Math.ceil(this.grid.resolution[0]) * Math.ceil(this.grid.resolution[1]) * Math.ceil(this.grid.resolution[2]);\n    \n    // Calculate dispatch size for grid clearing (handling 65535 limit)\n    // Total workgroups needed\n    const totalWorkgroups = Math.ceil(gridCellCount / WORKGROUP_SIZE);\n    const maxDispatchX = 65535;\n    this.gridDispatch = {\n        x: Math.min(totalWorkgroups, maxDispatchX),\n        y: Math.ceil(totalWorkgroups / maxDispatchX),\n        z: 1\n    };\n    // Stride for shader (in number of threads)\n    this.gridStride = this.gridDispatch.x * WORKGROUP_SIZE;\n\n    const gridSize = gridCellCount * 4;\n    const gridParticlesSize = gridCellCount * MAX_PARTICLES_PER_CELL * 4;\n    this.buffers = {\n      // Body buffers (double-buffered)\n      bodyPositionA: createStorageBuffer(device, bodySize, \"body-position-a\"),\n      bodyPositionB: createStorageBuffer(device, bodySize, \"body-position-b\"),\n      bodyQuaternionA: createStorageBuffer(device, bodySize, \"body-quaternion-a\"),\n      bodyQuaternionB: createStorageBuffer(device, bodySize, \"body-quaternion-b\"),\n      bodyVelocityA: createStorageBuffer(device, bodySize, \"body-velocity-a\"),\n      bodyVelocityB: createStorageBuffer(device, bodySize, \"body-velocity-b\"),\n      bodyAngularVelocityA: createStorageBuffer(device, bodySize, \"body-angular-velocity-a\"),\n      bodyAngularVelocityB: createStorageBuffer(device, bodySize, \"body-angular-velocity-b\"),\n      bodyForce: createStorageBuffer(device, bodySize, \"body-force\"),\n      bodyTorque: createStorageBuffer(device, bodySize, \"body-torque\"),\n      bodyMass: createStorageBuffer(device, bodySize, \"body-mass\"),\n      // Particle buffers\n      particleLocalPosition: createStorageBuffer(device, particleSize, \"particle-local-position\"),\n      particleRelativePosition: createStorageBuffer(device, particleSize, \"particle-relative-position\"),\n      particleWorldPosition: createStorageBuffer(device, particleSize, \"particle-world-position\"),\n      particleVelocity: createStorageBuffer(device, particleSize, \"particle-velocity\"),\n      particleForce: createStorageBuffer(device, particleSize, \"particle-force\"),\n      particleTorque: createStorageBuffer(device, particleSize, \"particle-torque\"),\n      // Broadphase grid\n      gridCellCount: createStorageBuffer(device, gridSize, \"grid-cell-count\"),\n      gridCellParticles: createStorageBuffer(device, gridParticlesSize, \"grid-cell-particles\"),\n      // Uniform params buffer (aligned to 256 bytes for uniform binding)\n      params: createUniformBuffer(device, alignTo(256, 256), \"params\"),\n      // Staging buffers for CPU readback\n      stagingPosition: createStagingBuffer(device, bodySize, \"staging-position\"),\n      stagingQuaternion: createStagingBuffer(device, bodySize, \"staging-quaternion\")\n    };\n  }\n  /**\n   * Create compute pipelines\n   */\n  async createPipelines() {\n    const device = this.device;\n    const makeShader = (code) => sharedWgsl + \"\\n\" + code;\n    const bufferLayout = (binding, type) => ({\n      binding,\n      visibility: GPUShaderStage.COMPUTE,\n      buffer: { type }\n    });\n    const makeLayout = (label, entries) => device.createBindGroupLayout({ label, entries });\n    const makePipeline = (label, module, layout) => device.createComputePipeline({\n      label,\n      layout: device.createPipelineLayout({\n        label: `${label}-layout`,\n        bindGroupLayouts: [layout]\n      }),\n      compute: {\n        module,\n        entryPoint: \"main\"\n      }\n    });\n    const modules = {\n      localToWorld: createShaderModule(device, makeShader(localToWorldWgsl), \"local-to-world\"),\n      localToRelative: createShaderModule(device, makeShader(localToRelativeWgsl), \"local-to-relative\"),\n      bodyVelToParticleVel: createShaderModule(device, makeShader(bodyVelToParticleVelWgsl), \"body-vel-to-particle-vel\"),\n      clearGrid: createShaderModule(device, makeShader(clearGridWgsl), \"clear-grid\"),\n      buildGrid: createShaderModule(device, makeShader(buildGridWgsl), \"build-grid\"),\n      updateForce: createShaderModule(device, makeShader(updateForceWgsl), \"update-force\"),\n      updateTorque: createShaderModule(device, makeShader(updateTorqueWgsl), \"update-torque\"),\n      reduceForce: createShaderModule(device, makeShader(reduceForceWgsl), \"reduce-force\"),\n      reduceTorque: createShaderModule(device, makeShader(reduceTorqueWgsl), \"reduce-torque\"),\n      updateBodyVelocity: createShaderModule(device, makeShader(updateBodyVelocityWgsl), \"update-body-velocity\"),\n      updateBodyAngularVelocity: createShaderModule(device, makeShader(updateBodyAngularVelocityWgsl), \"update-body-angular-velocity\"),\n      updateBodyPosition: createShaderModule(device, makeShader(updateBodyPositionWgsl), \"update-body-position\"),\n      updateBodyQuaternion: createShaderModule(device, makeShader(updateBodyQuaternionWgsl), \"update-body-quaternion\")\n    };\n    const layouts = {\n      localToWorld: makeLayout(\"layout/local-to-world\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"read-only-storage\"),\n        bufferLayout(3, \"read-only-storage\"),\n        bufferLayout(4, \"storage\")\n      ]),\n      localToRelative: makeLayout(\"layout/local-to-relative\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"read-only-storage\"),\n        bufferLayout(3, \"read-only-storage\"),\n        bufferLayout(4, \"storage\")\n      ]),\n      bodyVelToParticleVel: makeLayout(\"layout/body-vel-to-particle-vel\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"read-only-storage\"),\n        bufferLayout(3, \"read-only-storage\"),\n        bufferLayout(4, \"storage\")\n      ]),\n      clearGrid: makeLayout(\"layout/clear-grid\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"storage\")\n      ]),\n      buildGrid: makeLayout(\"layout/build-grid\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"storage\"),\n        bufferLayout(3, \"storage\")\n      ]),\n      updateForce: makeLayout(\"layout/update-force\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"read-only-storage\"),\n        bufferLayout(3, \"read-only-storage\"),\n        bufferLayout(4, \"read-only-storage\"),\n        bufferLayout(5, \"read-only-storage\"),\n        bufferLayout(6, \"read-only-storage\"),\n        bufferLayout(7, \"storage\")\n      ]),\n      updateTorque: makeLayout(\"layout/update-torque\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"read-only-storage\"),\n        bufferLayout(3, \"read-only-storage\"),\n        bufferLayout(4, \"read-only-storage\"),\n        bufferLayout(5, \"read-only-storage\"),\n        bufferLayout(6, \"read-only-storage\"),\n        bufferLayout(7, \"storage\")\n      ]),\n      reduceForce: makeLayout(\"layout/reduce-force\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"read-only-storage\"),\n        bufferLayout(3, \"storage\")\n      ]),\n      reduceTorque: makeLayout(\"layout/reduce-torque\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"read-only-storage\"),\n        bufferLayout(3, \"read-only-storage\"),\n        bufferLayout(4, \"read-only-storage\"),\n        bufferLayout(5, \"storage\")\n      ]),\n      updateBodyVelocity: makeLayout(\"layout/update-body-velocity\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"read-only-storage\"),\n        bufferLayout(3, \"read-only-storage\"),\n        bufferLayout(4, \"storage\")\n      ]),\n      updateBodyAngularVelocity: makeLayout(\"layout/update-body-angular-velocity\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"read-only-storage\"),\n        bufferLayout(3, \"read-only-storage\"),\n        bufferLayout(4, \"read-only-storage\"),\n        bufferLayout(5, \"storage\")\n      ]),\n      updateBodyPosition: makeLayout(\"layout/update-body-position\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"read-only-storage\"),\n        bufferLayout(3, \"storage\")\n      ]),\n      updateBodyQuaternion: makeLayout(\"layout/update-body-quaternion\", [\n        bufferLayout(0, \"uniform\"),\n        bufferLayout(1, \"read-only-storage\"),\n        bufferLayout(2, \"read-only-storage\"),\n        bufferLayout(3, \"storage\")\n      ])\n    };\n    this.layouts = layouts;\n    this.pipelines = {\n      localToWorld: makePipeline(\"local-to-world\", modules.localToWorld, layouts.localToWorld),\n      localToRelative: makePipeline(\"local-to-relative\", modules.localToRelative, layouts.localToRelative),\n      bodyVelToParticleVel: makePipeline(\"body-vel-to-particle-vel\", modules.bodyVelToParticleVel, layouts.bodyVelToParticleVel),\n      clearGrid: makePipeline(\"clear-grid\", modules.clearGrid, layouts.clearGrid),\n      buildGrid: makePipeline(\"build-grid\", modules.buildGrid, layouts.buildGrid),\n      updateForce: makePipeline(\"update-force\", modules.updateForce, layouts.updateForce),\n      updateTorque: makePipeline(\"update-torque\", modules.updateTorque, layouts.updateTorque),\n      reduceForce: makePipeline(\"reduce-force\", modules.reduceForce, layouts.reduceForce),\n      reduceTorque: makePipeline(\"reduce-torque\", modules.reduceTorque, layouts.reduceTorque),\n      updateBodyVelocity: makePipeline(\"update-body-velocity\", modules.updateBodyVelocity, layouts.updateBodyVelocity),\n      updateBodyAngularVelocity: makePipeline(\"update-body-angular-velocity\", modules.updateBodyAngularVelocity, layouts.updateBodyAngularVelocity),\n      updateBodyPosition: makePipeline(\"update-body-position\", modules.updateBodyPosition, layouts.updateBodyPosition),\n      updateBodyQuaternion: makePipeline(\"update-body-quaternion\", modules.updateBodyQuaternion, layouts.updateBodyQuaternion)\n    };\n  }\n  /**\n   * Create bind groups for each pipeline\n   */\n  createBindGroups() {\n    this.updateBindGroups();\n  }\n  /**\n   * Update bind groups after buffer swap\n   */\n  updateBindGroups() {\n    const device = this.device;\n    const buffers = this.buffers;\n    const layouts = this.layouts;\n    const posRead = this.bufferIndex === 0 ? buffers.bodyPositionA : buffers.bodyPositionB;\n    const posWrite = this.bufferIndex === 0 ? buffers.bodyPositionB : buffers.bodyPositionA;\n    const quatRead = this.bufferIndex === 0 ? buffers.bodyQuaternionA : buffers.bodyQuaternionB;\n    const quatWrite = this.bufferIndex === 0 ? buffers.bodyQuaternionB : buffers.bodyQuaternionA;\n    const velRead = this.bufferIndex === 0 ? buffers.bodyVelocityA : buffers.bodyVelocityB;\n    const velWrite = this.bufferIndex === 0 ? buffers.bodyVelocityB : buffers.bodyVelocityA;\n    const angVelRead = this.bufferIndex === 0 ? buffers.bodyAngularVelocityA : buffers.bodyAngularVelocityB;\n    const angVelWrite = this.bufferIndex === 0 ? buffers.bodyAngularVelocityB : buffers.bodyAngularVelocityA;\n    this.bindGroups.set(\"localToWorld\", device.createBindGroup({\n      layout: layouts.localToWorld,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleLocalPosition } },\n        { binding: 2, resource: { buffer: posRead } },\n        { binding: 3, resource: { buffer: quatRead } },\n        { binding: 4, resource: { buffer: buffers.particleWorldPosition } }\n      ]\n    }));\n    this.bindGroups.set(\"localToRelative\", device.createBindGroup({\n      layout: layouts.localToRelative,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleLocalPosition } },\n        { binding: 2, resource: { buffer: posRead } },\n        { binding: 3, resource: { buffer: quatRead } },\n        { binding: 4, resource: { buffer: buffers.particleRelativePosition } }\n      ]\n    }));\n    this.bindGroups.set(\"bodyVelToParticleVel\", device.createBindGroup({\n      layout: layouts.bodyVelToParticleVel,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleRelativePosition } },\n        { binding: 2, resource: { buffer: velRead } },\n        { binding: 3, resource: { buffer: angVelRead } },\n        { binding: 4, resource: { buffer: buffers.particleVelocity } }\n      ]\n    }));\n    this.bindGroups.set(\"clearGrid\", device.createBindGroup({\n      layout: layouts.clearGrid,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.gridCellCount } }\n      ]\n    }));\n    this.bindGroups.set(\"buildGrid\", device.createBindGroup({\n      layout: layouts.buildGrid,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleWorldPosition } },\n        { binding: 2, resource: { buffer: buffers.gridCellCount } },\n        { binding: 3, resource: { buffer: buffers.gridCellParticles } }\n      ]\n    }));\n    this.bindGroups.set(\"updateForce\", device.createBindGroup({\n      layout: layouts.updateForce,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleWorldPosition } },\n        { binding: 2, resource: { buffer: buffers.particleRelativePosition } },\n        { binding: 3, resource: { buffer: buffers.particleVelocity } },\n        { binding: 4, resource: { buffer: angVelRead } },\n        { binding: 5, resource: { buffer: buffers.gridCellCount } },\n        { binding: 6, resource: { buffer: buffers.gridCellParticles } },\n        { binding: 7, resource: { buffer: buffers.particleForce } }\n      ]\n    }));\n    this.bindGroups.set(\"updateTorque\", device.createBindGroup({\n      layout: layouts.updateTorque,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleWorldPosition } },\n        { binding: 2, resource: { buffer: buffers.particleRelativePosition } },\n        { binding: 3, resource: { buffer: buffers.particleVelocity } },\n        { binding: 4, resource: { buffer: angVelRead } },\n        { binding: 5, resource: { buffer: buffers.gridCellCount } },\n        { binding: 6, resource: { buffer: buffers.gridCellParticles } },\n        { binding: 7, resource: { buffer: buffers.particleTorque } }\n      ]\n    }));\n    this.bindGroups.set(\"reduceForce\", device.createBindGroup({\n      layout: layouts.reduceForce,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleLocalPosition } },\n        { binding: 2, resource: { buffer: buffers.particleForce } },\n        { binding: 3, resource: { buffer: buffers.bodyForce } }\n      ]\n    }));\n    this.bindGroups.set(\"reduceTorque\", device.createBindGroup({\n      layout: layouts.reduceTorque,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: buffers.particleLocalPosition } },\n        { binding: 2, resource: { buffer: buffers.particleRelativePosition } },\n        { binding: 3, resource: { buffer: buffers.particleForce } },\n        { binding: 4, resource: { buffer: buffers.particleTorque } },\n        { binding: 5, resource: { buffer: buffers.bodyTorque } }\n      ]\n    }));\n    this.bindGroups.set(\"updateBodyVelocity\", device.createBindGroup({\n      layout: layouts.updateBodyVelocity,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: velRead } },\n        { binding: 2, resource: { buffer: buffers.bodyForce } },\n        { binding: 3, resource: { buffer: buffers.bodyMass } },\n        { binding: 4, resource: { buffer: velWrite } }\n      ]\n    }));\n    this.bindGroups.set(\"updateBodyAngularVelocity\", device.createBindGroup({\n      layout: layouts.updateBodyAngularVelocity,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: angVelRead } },\n        { binding: 2, resource: { buffer: buffers.bodyTorque } },\n        { binding: 3, resource: { buffer: buffers.bodyMass } },\n        { binding: 4, resource: { buffer: quatRead } },\n        { binding: 5, resource: { buffer: angVelWrite } }\n      ]\n    }));\n    this.bindGroups.set(\"updateBodyPosition\", device.createBindGroup({\n      layout: layouts.updateBodyPosition,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: posRead } },\n        { binding: 2, resource: { buffer: velWrite } },\n        // Use updated velocity\n        { binding: 3, resource: { buffer: posWrite } }\n      ]\n    }));\n    this.bindGroups.set(\"updateBodyQuaternion\", device.createBindGroup({\n      layout: layouts.updateBodyQuaternion,\n      entries: [\n        { binding: 0, resource: { buffer: buffers.params } },\n        { binding: 1, resource: { buffer: quatRead } },\n        { binding: 2, resource: { buffer: angVelWrite } },\n        // Use updated angular velocity\n        { binding: 3, resource: { buffer: quatWrite } }\n      ]\n    }));\n  }\n  /**\n   * Swap double-buffered resources\n   */\n  swapBuffers() {\n    this.bufferIndex = 1 - this.bufferIndex;\n    this.updateBindGroups();\n  }\n  /**\n   * Sync CPU data to GPU\n   */\n  flushData() {\n    if (this.bodyDataDirty) {\n      writeBuffer(this.device, this.buffers.bodyPositionA, this.bodyPositions);\n      writeBuffer(this.device, this.buffers.bodyPositionB, this.bodyPositions);\n      writeBuffer(this.device, this.buffers.bodyQuaternionA, this.bodyQuaternions);\n      writeBuffer(this.device, this.buffers.bodyQuaternionB, this.bodyQuaternions);\n      this.bodyDataDirty = false;\n    }\n    if (this.particleDataDirty) {\n      writeBuffer(this.device, this.buffers.particleLocalPosition, this.particleLocalPositions);\n      this.particleDataDirty = false;\n    }\n    if (this.massDirty) {\n      writeBuffer(this.device, this.buffers.bodyMass, this.bodyMasses);\n      this.massDirty = false;\n    }\n    this.updateParamsBuffer();\n  }\n  /**\n   * Update the params uniform buffer\n   */\n  updateParamsBuffer() {\n    const data = new Float32Array(32);\n    data[0] = this.params.stiffness;\n    data[1] = this.params.damping;\n    data[2] = this.params.radius;\n    data[3] = this._particleCount;\n    data[4] = this.params.fixedTimeStep;\n    data[5] = this.params.friction;\n    data[6] = this.params.drag;\n    data[7] = this._bodyCount;\n    data[8] = this.params.gravity[0];\n    data[9] = this.params.gravity[1];\n    data[10] = this.params.gravity[2];\n    data[11] = 0;\n    data[12] = this.params.boxSize[0];\n    data[13] = this.params.boxSize[1];\n    data[14] = this.params.boxSize[2];\n    data[15] = 0;\n    data[16] = this.grid.position[0];\n    data[17] = this.grid.position[1];\n    data[18] = this.grid.position[2];\n    data[19] = 0;\n    data[20] = this.grid.resolution[0];\n    data[21] = this.grid.resolution[1];\n    data[22] = this.grid.resolution[2];\n    data[23] = this.grid.maxParticlesPerCell;\n    data[24] = this.interactionSphere.position.x;\n    data[25] = this.interactionSphere.position.y;\n    data[26] = this.interactionSphere.position.z;\n    data[27] = this.interactionSphere.radius;\n    const maxV = 2 * this.params.radius / this.params.fixedTimeStep;\n    data[28] = maxV;\n    data[29] = maxV;\n    data[30] = maxV;\n    // Store grid stride in w component of maxVelocity for clear_grid shader\n    data[31] = this.gridStride || 0; \n    writeBuffer(this.device, this.buffers.params, data);\n  }\n  /**\n   * Add a rigid body to the simulation\n   */\n  addBody(x, y, z, qx, qy, qz, qw, mass, inertiaX, inertiaY, inertiaZ) {\n    if (this._bodyCount >= this.maxBodies) {\n      console.warn(`Cannot add body: maximum (${this.maxBodies}) reached`);\n      return -1;\n    }\n    const id = this._bodyCount;\n    const offset = id * 4;\n    this.bodyPositions[offset] = x;\n    this.bodyPositions[offset + 1] = y;\n    this.bodyPositions[offset + 2] = z;\n    this.bodyPositions[offset + 3] = 1;\n    this.bodyQuaternions[offset] = qx;\n    this.bodyQuaternions[offset + 1] = qy;\n    this.bodyQuaternions[offset + 2] = qz;\n    this.bodyQuaternions[offset + 3] = qw;\n    this.bodyMasses[offset] = inertiaX > 0 ? 1 / inertiaX : 0;\n    this.bodyMasses[offset + 1] = inertiaY > 0 ? 1 / inertiaY : 0;\n    this.bodyMasses[offset + 2] = inertiaZ > 0 ? 1 / inertiaZ : 0;\n    this.bodyMasses[offset + 3] = mass > 0 ? 1 / mass : 0;\n    this._bodyCount++;\n    this.bodyDataDirty = true;\n    this.massDirty = true;\n    return id;\n  }\n  /**\n   * Add a collision particle to a body\n   */\n  addParticle(bodyId, x, y, z) {\n    if (this._particleCount >= this.maxParticles) {\n      console.warn(`Cannot add particle: maximum (${this.maxParticles}) reached`);\n      return -1;\n    }\n    const id = this._particleCount;\n    const offset = id * 4;\n    this.particleLocalPositions[offset] = x;\n    this.particleLocalPositions[offset + 1] = y;\n    this.particleLocalPositions[offset + 2] = z;\n    this.particleLocalPositions[offset + 3] = bodyId;\n    this._particleCount++;\n    this.particleDataDirty = true;\n    return id;\n  }\n  /**\n   * Step the simulation forward by deltaTime\n   */\n  step(deltaTime) {\n    if (!this.initialized) {\n      console.warn(\"World not initialized. Call await world.ready() first.\");\n      return;\n    }\n    this.accumulator += deltaTime;\n    let substeps = 0;\n    while (this.accumulator >= this.params.fixedTimeStep && substeps < this.maxSubSteps) {\n      this.singleStep();\n      this.accumulator -= this.params.fixedTimeStep;\n      substeps++;\n    }\n    this._interpolationValue = this.accumulator / this.params.fixedTimeStep;\n    this.time += deltaTime;\n  }\n  /**\n   * Execute a single physics step\n   */\n  singleStep() {\n    this.flushData();\n    const encoder = this.device.createCommandEncoder({ label: \"physics-step\" });\n    encoder.clearBuffer(this.buffers.bodyForce);\n    encoder.clearBuffer(this.buffers.bodyTorque);\n    encoder.clearBuffer(this.buffers.gridCellParticles);\n    const particleDispatch = getDispatchSize(this._particleCount, WORKGROUP_SIZE);\n    const bodyDispatch = getDispatchSize(this._bodyCount, WORKGROUP_SIZE);\n    // gridDispatch is calculated in createBuffers/constructor\n    {\n      const pass = encoder.beginComputePass({ label: \"local-to-world\" });\n      pass.setPipeline(this.pipelines.localToWorld);\n      pass.setBindGroup(0, this.bindGroups.get(\"localToWorld\"));\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"local-to-relative\" });\n      pass.setPipeline(this.pipelines.localToRelative);\n      pass.setBindGroup(0, this.bindGroups.get(\"localToRelative\"));\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"body-vel-to-particle-vel\" });\n      pass.setPipeline(this.pipelines.bodyVelToParticleVel);\n      pass.setBindGroup(0, this.bindGroups.get(\"bodyVelToParticleVel\"));\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"clear-grid\" });\n      pass.setPipeline(this.pipelines.clearGrid);\n      pass.setBindGroup(0, this.bindGroups.get(\"clearGrid\"));\n      pass.dispatchWorkgroups(this.gridDispatch.x, this.gridDispatch.y, this.gridDispatch.z);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"build-grid\" });\n      pass.setPipeline(this.pipelines.buildGrid);\n      pass.setBindGroup(0, this.bindGroups.get(\"buildGrid\"));\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"update-force\" });\n      pass.setPipeline(this.pipelines.updateForce);\n      pass.setBindGroup(0, this.bindGroups.get(\"updateForce\"));\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"update-torque\" });\n      pass.setPipeline(this.pipelines.updateTorque);\n      pass.setBindGroup(0, this.bindGroups.get(\"updateTorque\"));\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"reduce-force\" });\n      pass.setPipeline(this.pipelines.reduceForce);\n      pass.setBindGroup(0, this.bindGroups.get(\"reduceForce\"));\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"reduce-torque\" });\n      pass.setPipeline(this.pipelines.reduceTorque);\n      pass.setBindGroup(0, this.bindGroups.get(\"reduceTorque\"));\n      pass.dispatchWorkgroups(particleDispatch);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"update-body-velocity\" });\n      pass.setPipeline(this.pipelines.updateBodyVelocity);\n      pass.setBindGroup(0, this.bindGroups.get(\"updateBodyVelocity\"));\n      pass.dispatchWorkgroups(bodyDispatch);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"update-body-angular-velocity\" });\n      pass.setPipeline(this.pipelines.updateBodyAngularVelocity);\n      pass.setBindGroup(0, this.bindGroups.get(\"updateBodyAngularVelocity\"));\n      pass.dispatchWorkgroups(bodyDispatch);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"update-body-position\" });\n      pass.setPipeline(this.pipelines.updateBodyPosition);\n      pass.setBindGroup(0, this.bindGroups.get(\"updateBodyPosition\"));\n      pass.dispatchWorkgroups(bodyDispatch);\n      pass.end();\n    }\n    {\n      const pass = encoder.beginComputePass({ label: \"update-body-quaternion\" });\n      pass.setPipeline(this.pipelines.updateBodyQuaternion);\n      pass.setBindGroup(0, this.bindGroups.get(\"updateBodyQuaternion\"));\n      pass.dispatchWorkgroups(bodyDispatch);\n      pass.end();\n    }\n    this.device.queue.submit([encoder.finish()]);\n    this.swapBuffers();\n    this.fixedTime += this.params.fixedTimeStep;\n  }\n  // Property getters and setters\n  get bodyCount() {\n    return this._bodyCount;\n  }\n  get particleCount() {\n    return this._particleCount;\n  }\n  /**\n   * Expose GPU buffers for rendering\n   */\n  getParticleWorldPositionBuffer() {\n    return this.buffers.particleWorldPosition;\n  }\n  // Backward/compat alias\n  getParticlePositionBuffer() {\n    return this.getParticleWorldPositionBuffer();\n  }\n  getParamsBuffer() {\n    return this.buffers.params;\n  }\n  get interpolationValue() {\n    return this._interpolationValue;\n  }\n  get stiffness() {\n    return this.params.stiffness;\n  }\n  set stiffness(v) {\n    this.params.stiffness = v;\n  }\n  get damping() {\n    return this.params.damping;\n  }\n  set damping(v) {\n    this.params.damping = v;\n  }\n  get friction() {\n    return this.params.friction;\n  }\n  set friction(v) {\n    this.params.friction = v;\n  }\n  get drag() {\n    return this.params.drag;\n  }\n  set drag(v) {\n    this.params.drag = v;\n  }\n  get radius() {\n    return this.params.radius;\n  }\n  set radius(v) {\n    this.params.radius = v;\n  }\n  get fixedTimeStep() {\n    return this.params.fixedTimeStep;\n  }\n  set fixedTimeStep(v) {\n    this.params.fixedTimeStep = v;\n  }\n  get gravity() {\n    return new Vec3(this.params.gravity[0], this.params.gravity[1], this.params.gravity[2]);\n  }\n  set gravity(v) {\n    this.params.gravity[0] = v.x;\n    this.params.gravity[1] = v.y;\n    this.params.gravity[2] = v.z;\n  }\n  /**\n   * Set interaction sphere position\n   */\n  setSpherePosition(index, x, y, z) {\n    if (index !== 0) throw new Error(\"Multiple spheres not supported yet\");\n    this.interactionSphere.position.set(x, y, z);\n  }\n  /**\n   * Get interaction sphere position\n   */\n  getSpherePosition(index, out) {\n    if (index !== 0) throw new Error(\"Multiple spheres not supported yet\");\n    out = out || new Vec3();\n    out.copy(this.interactionSphere.position);\n    return out;\n  }\n  /**\n   * Set interaction sphere radius\n   */\n  setSphereRadius(index, radius) {\n    if (index !== 0) throw new Error(\"Multiple spheres not supported yet\");\n    this.interactionSphere.radius = radius;\n  }\n  /**\n   * Get interaction sphere radius\n   */\n  getSphereRadius(index) {\n    if (index !== 0) throw new Error(\"Multiple spheres not supported yet\");\n    return this.interactionSphere.radius;\n  }\n  /**\n   * Read body positions from GPU (async)\n   */\n  async readBodyPositions() {\n    const size = this._bodyCount * 4 * 4;\n    const posBuffer = this.bufferIndex === 0 ? this.buffers.bodyPositionA : this.buffers.bodyPositionB;\n    const data = await readBuffer(this.device, posBuffer, this.buffers.stagingPosition, size);\n    return new Float32Array(data);\n  }\n  /**\n   * Read body quaternions from GPU (async)\n   */\n  async readBodyQuaternions() {\n    const size = this._bodyCount * 4 * 4;\n    const quatBuffer = this.bufferIndex === 0 ? this.buffers.bodyQuaternionA : this.buffers.bodyQuaternionB;\n    const data = await readBuffer(this.device, quatBuffer, this.buffers.stagingQuaternion, size);\n    return new Float32Array(data);\n  }\n  /**\n   * Get the WebGPU device (for rendering integration)\n   */\n  getDevice() {\n    return this.device;\n  }\n  /**\n   * Get body position buffer for rendering\n   */\n  getBodyPositionBuffer() {\n    return this.bufferIndex === 0 ? this.buffers.bodyPositionA : this.buffers.bodyPositionB;\n  }\n  /**\n   * Get body quaternion buffer for rendering  \n   */\n  getBodyQuaternionBuffer() {\n    return this.bufferIndex === 0 ? this.buffers.bodyQuaternionA : this.buffers.bodyQuaternionB;\n  }\n  /**\n   * Destroy all GPU resources\n   */\n  destroy() {\n    if (!this.initialized) return;\n    Object.values(this.buffers).forEach((buffer) => {\n      if (buffer && typeof buffer.destroy === \"function\") {\n        buffer.destroy();\n      }\n    });\n    this.bindGroups.clear();\n    this.initialized = false;\n  }\n}\nexport {\n  World\n};\n","import { World } from \"./world.js\";\nimport { initWebGPU, isWebGPUSupported } from \"./device.js\";\nimport { Vec3, Vec4, Quat, Mat3 } from \"./math.js\";\nconst VERSION = \"1.0.0\";\nexport {\n  Mat3,\n  Quat,\n  VERSION,\n  Vec3,\n  Vec4,\n  World,\n  initWebGPU,\n  isWebGPUSupported\n};\n"],"names":["Vec3","x","y","z","v","s","ax","ay","az","bx","by","bz","len","a","b","out","Vec4","w","Quat","q","invLen","angularVelocity","dt","halfDt","wx","wy","wz","qx","qy","qz","qw","ix","iy","iz","iw","axis","angle","halfAngle","aw","bw","t","d","theta0","theta","sinTheta","sinTheta0","s0","s1","Mat3","x2","y2","z2","xx","xy","xz","yy","yz","zz","m","tmp","ae","be","isWebGPUSupported","initWebGPU","adapter","info","requiredFeatures","device","lossInfo","event","createShaderModule","code","label","createStorageBuffer","size","mappedAtCreation","createUniformBuffer","createStagingBuffer","writeBuffer","buffer","data","offset","readBuffer","sourceBuffer","stagingBuffer","commandEncoder","copyData","alignTo","alignment","getDispatchSize","numElements","workgroupSize","sharedWgsl","localToWorldWgsl","localToRelativeWgsl","bodyVelToParticleVelWgsl","clearGridWgsl","buildGridWgsl","updateForceWgsl","updateTorqueWgsl","reduceForceWgsl","reduceTorqueWgsl","updateBodyVelocityWgsl","updateBodyAngularVelocityWgsl","updateBodyPositionWgsl","updateBodyQuaternionWgsl","WORKGROUP_SIZE","MAX_PARTICLES_PER_CELL","World","options","__publicField","_a","_b","_c","gridRes","i","bodySize","particleSize","gridCellCount","totalWorkgroups","maxDispatchX","gridSize","gridParticlesSize","makeShader","bufferLayout","binding","type","makeLayout","entries","makePipeline","module","layout","modules","layouts","buffers","posRead","posWrite","quatRead","quatWrite","velRead","velWrite","angVelRead","angVelWrite","maxV","mass","inertiaX","inertiaY","inertiaZ","id","bodyId","deltaTime","substeps","encoder","particleDispatch","bodyDispatch","pass","index","radius","posBuffer","quatBuffer","VERSION"],"mappings":"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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAfC,IAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GC0BTC,IAAiB,IACjBC,IAAyB;AAC/B,MAAMC,EAAM;AAAA,EA0CV,YAAYC,IAAU,IAAI;AAxC1B;AAAA,IAAAC,EAAA;AACA,IAAAA,EAAA;AAEA;AAAA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA,oBAA6B,oBAAI,IAAG;AAEpC;AAAA,IAAAA,EAAA,oBAAa;AACb,IAAAA,EAAA,wBAAiB;AACjB,IAAAA,EAAA;AACA,IAAAA,EAAA;AAEA;AAAA,IAAAA,EAAA;AACA,IAAAA,EAAA;AAEA;AAAA,IAAAA,EAAA,cAAO;AACP,IAAAA,EAAA,mBAAY;AACZ,IAAAA,EAAA,qBAAc;AACd,IAAAA,EAAA;AACA,IAAAA,EAAA,6BAAsB;AAEtB;AAAA,IAAAA,EAAA,qBAAc;AAEd;AAAA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AACA,IAAAA,EAAA;AAEA;AAAA,IAAAA,EAAA,uBAAgB;AAChB,IAAAA,EAAA,2BAAoB;AACpB,IAAAA,EAAA,mBAAY;AAEZ;AAAA,IAAAA,EAAA,2BAAoB;AAAA,MAClB,UAAU,IAAI9G,EAAK,IAAI,GAAG,CAAC;AAAA,MAC3B,QAAQ;AAAA,IACZ;AAEE;AAAA,IAAA8G,EAAA;AACA,IAAAA,EAAA,qBAAc;AhBrEhB,QAAAC,GAAAC,GAAAC;AgBuEI,SAAK,YAAYJ,EAAQ,aAAa,IACtC,KAAK,eAAeA,EAAQ,gBAAgB,KAC5C,KAAK,cAAcA,EAAQ,eAAe,GAC1C,KAAK,SAAS;AAAA,MACZ,WAAWA,EAAQ,aAAa;AAAA,MAChC,SAASA,EAAQ,WAAW;AAAA,MAC5B,UAAUA,EAAQ,YAAY;AAAA,MAC9B,MAAMA,EAAQ,QAAQ;AAAA,MACtB,QAAQA,EAAQ,UAAU;AAAA,MAC1B,eAAeA,EAAQ,iBAAiB,IAAI;AAAA,MAC5C,WAASE,IAAAF,EAAQ,YAAR,gBAAAE,EAAiB,SAAQ,IAAI,aAAa,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,MAChE,WAASC,IAAAH,EAAQ,YAAR,gBAAAG,EAAiB,SAAQ,IAAI,aAAa,CAAC,IAAI,IAAI,EAAE,CAAC;AAAA,IACrE;AACI,UAAME,IAAUL,EAAQ,kBAAkB,IAAI7G,EAAK,IAAI,IAAI,EAAE;AAC7D,SAAK,OAAO;AAAA,MACV,YAAUiH,IAAAJ,EAAQ,iBAAR,gBAAAI,EAAsB,SAAQ,IAAI,aAAa,CAAC,GAAG,GAAG,CAAC,CAAC;AAAA,MAClE,YAAYC,EAAQ;AAAA,MACpB,qBAAqBP;AAAA,IAC3B,GACI,KAAK,gBAAgB,IAAI,aAAa,KAAK,YAAY,CAAC,GACxD,KAAK,kBAAkB,IAAI,aAAa,KAAK,YAAY,CAAC,GAC1D,KAAK,aAAa,IAAI,aAAa,KAAK,YAAY,CAAC,GACrD,KAAK,yBAAyB,IAAI,aAAa,KAAK,eAAe,CAAC;AACpE,aAASQ,IAAI,GAAGA,IAAI,KAAK,WAAWA;AAClC,WAAK,gBAAgBA,IAAI,IAAI,CAAC,IAAI;AAEpC,SAAK,cAAc,KAAK,WAAU;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,aAAa;AACjB,SAAK,MAAM,MAAMpD,EAAU,GAC3B,KAAK,SAAS,KAAK,IAAI,QACvB,KAAK,cAAa,GAClB,MAAM,KAAK,gBAAe,GAC1B,KAAK,iBAAgB,GACrB,KAAK,cAAc;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,QAAQ;AACZ,UAAM,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA,EAIA,gBAAgB;AACd,UAAMI,IAAS,KAAK,QACdiD,IAAW,KAAK,YAAY,IAAI,GAChCC,IAAe,KAAK,eAAe,IAAI,GACvCC,IAAgB,KAAK,KAAK,KAAK,KAAK,WAAW,CAAC,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,WAAW,CAAC,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,WAAW,CAAC,CAAC,GAI3HC,IAAkB,KAAK,KAAKD,IAAgBZ,CAAc,GAC1Dc,IAAe;AACrB,SAAK,eAAe;AAAA,MAChB,GAAG,KAAK,IAAID,GAAiBC,CAAY;AAAA,MACzC,GAAG,KAAK,KAAKD,IAAkBC,CAAY;AAAA,MAC3C,GAAG;AAAA,IACX,GAEI,KAAK,aAAa,KAAK,aAAa,IAAId;AAExC,UAAMe,IAAWH,IAAgB,GAC3BI,IAAoBJ,IAAgBX,IAAyB;AACnE,SAAK,UAAU;AAAA;AAAA,MAEb,eAAelC,EAAoBN,GAAQiD,GAAU,iBAAiB;AAAA,MACtE,eAAe3C,EAAoBN,GAAQiD,GAAU,iBAAiB;AAAA,MACtE,iBAAiB3C,EAAoBN,GAAQiD,GAAU,mBAAmB;AAAA,MAC1E,iBAAiB3C,EAAoBN,GAAQiD,GAAU,mBAAmB;AAAA,MAC1E,eAAe3C,EAAoBN,GAAQiD,GAAU,iBAAiB;AAAA,MACtE,eAAe3C,EAAoBN,GAAQiD,GAAU,iBAAiB;AAAA,MACtE,sBAAsB3C,EAAoBN,GAAQiD,GAAU,yBAAyB;AAAA,MACrF,sBAAsB3C,EAAoBN,GAAQiD,GAAU,yBAAyB;AAAA,MACrF,WAAW3C,EAAoBN,GAAQiD,GAAU,YAAY;AAAA,MAC7D,YAAY3C,EAAoBN,GAAQiD,GAAU,aAAa;AAAA,MAC/D,UAAU3C,EAAoBN,GAAQiD,GAAU,WAAW;AAAA;AAAA,MAE3D,uBAAuB3C,EAAoBN,GAAQkD,GAAc,yBAAyB;AAAA,MAC1F,0BAA0B5C,EAAoBN,GAAQkD,GAAc,4BAA4B;AAAA,MAChG,uBAAuB5C,EAAoBN,GAAQkD,GAAc,yBAAyB;AAAA,MAC1F,kBAAkB5C,EAAoBN,GAAQkD,GAAc,mBAAmB;AAAA,MAC/E,eAAe5C,EAAoBN,GAAQkD,GAAc,gBAAgB;AAAA,MACzE,gBAAgB5C,EAAoBN,GAAQkD,GAAc,iBAAiB;AAAA;AAAA,MAE3E,eAAe5C,EAAoBN,GAAQsD,GAAU,iBAAiB;AAAA,MACtE,mBAAmBhD,EAAoBN,GAAQuD,GAAmB,qBAAqB;AAAA;AAAA,MAEvF,QAAQ9C,EAAoBT,GAAQoB,EAAQ,KAAK,GAAG,GAAG,QAAQ;AAAA;AAAA,MAE/D,iBAAiBV,EAAoBV,GAAQiD,GAAU,kBAAkB;AAAA,MACzE,mBAAmBvC,EAAoBV,GAAQiD,GAAU,oBAAoB;AAAA,IACnF;AAAA,EACE;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,kBAAkB;AACtB,UAAMjD,IAAS,KAAK,QACdwD,IAAa,CAACpD,MAASqB,IAAa;AAAA,IAAOrB,GAC3CqD,IAAe,CAACC,GAASC,OAAU;AAAA,MACvC,SAAAD;AAAA,MACA,YAAY,eAAe;AAAA,MAC3B,QAAQ,EAAE,MAAAC,EAAI;AAAA,IACpB,IACUC,IAAa,CAACvD,GAAOwD,MAAY7D,EAAO,sBAAsB,EAAE,OAAAK,GAAO,SAAAwD,GAAS,GAChFC,IAAe,CAACzD,GAAO0D,GAAQC,MAAWhE,EAAO,sBAAsB;AAAA,MAC3E,OAAAK;AAAA,MACA,QAAQL,EAAO,qBAAqB;AAAA,QAClC,OAAO,GAAGK,CAAK;AAAA,QACf,kBAAkB,CAAC2D,CAAM;AAAA,MACjC,CAAO;AAAA,MACD,SAAS;AAAA,QACP,QAAAD;AAAA,QACA,YAAY;AAAA,MACpB;AAAA,IACA,CAAK,GACKE,IAAU;AAAA,MACd,cAAc9D,EAAmBH,GAAQwD,EAAW9B,CAAgB,GAAG,gBAAgB;AAAA,MACvF,iBAAiBvB,EAAmBH,GAAQwD,EAAW7B,CAAmB,GAAG,mBAAmB;AAAA,MAChG,sBAAsBxB,EAAmBH,GAAQwD,EAAW5B,CAAwB,GAAG,0BAA0B;AAAA,MACjH,WAAWzB,EAAmBH,GAAQwD,EAAW3B,CAAa,GAAG,YAAY;AAAA,MAC7E,WAAW1B,EAAmBH,GAAQwD,EAAW1B,CAAa,GAAG,YAAY;AAAA,MAC7E,aAAa3B,EAAmBH,GAAQwD,EAAWzB,CAAe,GAAG,cAAc;AAAA,MACnF,cAAc5B,EAAmBH,GAAQwD,EAAWxB,CAAgB,GAAG,eAAe;AAAA,MACtF,aAAa7B,EAAmBH,GAAQwD,EAAWvB,CAAe,GAAG,cAAc;AAAA,MACnF,cAAc9B,EAAmBH,GAAQwD,EAAWtB,CAAgB,GAAG,eAAe;AAAA,MACtF,oBAAoB/B,EAAmBH,GAAQwD,EAAWrB,CAAsB,GAAG,sBAAsB;AAAA,MACzG,2BAA2BhC,EAAmBH,GAAQwD,EAAWpB,CAA6B,GAAG,8BAA8B;AAAA,MAC/H,oBAAoBjC,EAAmBH,GAAQwD,EAAWnB,CAAsB,GAAG,sBAAsB;AAAA,MACzG,sBAAsBlC,EAAmBH,GAAQwD,EAAWlB,CAAwB,GAAG,wBAAwB;AAAA,IACrH,GACU4B,IAAU;AAAA,MACd,cAAcN,EAAW,yBAAyB;AAAA,QAChDH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,iBAAiBG,EAAW,4BAA4B;AAAA,QACtDH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,sBAAsBG,EAAW,mCAAmC;AAAA,QAClEH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,WAAWG,EAAW,qBAAqB;AAAA,QACzCH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,WAAWG,EAAW,qBAAqB;AAAA,QACzCH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,aAAaG,EAAW,uBAAuB;AAAA,QAC7CH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,cAAcG,EAAW,wBAAwB;AAAA,QAC/CH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,aAAaG,EAAW,uBAAuB;AAAA,QAC7CH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,cAAcG,EAAW,wBAAwB;AAAA,QAC/CH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,oBAAoBG,EAAW,+BAA+B;AAAA,QAC5DH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,2BAA2BG,EAAW,uCAAuC;AAAA,QAC3EH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,oBAAoBG,EAAW,+BAA+B;AAAA,QAC5DH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,MACD,sBAAsBG,EAAW,iCAAiC;AAAA,QAChEH,EAAa,GAAG,SAAS;AAAA,QACzBA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,mBAAmB;AAAA,QACnCA,EAAa,GAAG,SAAS;AAAA,MACjC,CAAO;AAAA,IACP;AACI,SAAK,UAAUS,GACf,KAAK,YAAY;AAAA,MACf,cAAcJ,EAAa,kBAAkBG,EAAQ,cAAcC,EAAQ,YAAY;AAAA,MACvF,iBAAiBJ,EAAa,qBAAqBG,EAAQ,iBAAiBC,EAAQ,eAAe;AAAA,MACnG,sBAAsBJ,EAAa,4BAA4BG,EAAQ,sBAAsBC,EAAQ,oBAAoB;AAAA,MACzH,WAAWJ,EAAa,cAAcG,EAAQ,WAAWC,EAAQ,SAAS;AAAA,MAC1E,WAAWJ,EAAa,cAAcG,EAAQ,WAAWC,EAAQ,SAAS;AAAA,MAC1E,aAAaJ,EAAa,gBAAgBG,EAAQ,aAAaC,EAAQ,WAAW;AAAA,MAClF,cAAcJ,EAAa,iBAAiBG,EAAQ,cAAcC,EAAQ,YAAY;AAAA,MACtF,aAAaJ,EAAa,gBAAgBG,EAAQ,aAAaC,EAAQ,WAAW;AAAA,MAClF,cAAcJ,EAAa,iBAAiBG,EAAQ,cAAcC,EAAQ,YAAY;AAAA,MACtF,oBAAoBJ,EAAa,wBAAwBG,EAAQ,oBAAoBC,EAAQ,kBAAkB;AAAA,MAC/G,2BAA2BJ,EAAa,gCAAgCG,EAAQ,2BAA2BC,EAAQ,yBAAyB;AAAA,MAC5I,oBAAoBJ,EAAa,wBAAwBG,EAAQ,oBAAoBC,EAAQ,kBAAkB;AAAA,MAC/G,sBAAsBJ,EAAa,0BAA0BG,EAAQ,sBAAsBC,EAAQ,oBAAoB;AAAA,IAC7H;AAAA,EACE;AAAA;AAAA;AAAA;AAAA,EAIA,mBAAmB;AACjB,SAAK,iBAAgB;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAIA,mBAAmB;AACjB,UAAMlE,IAAS,KAAK,QACdmE,IAAU,KAAK,SACfD,IAAU,KAAK,SACfE,IAAU,KAAK,gBAAgB,IAAID,EAAQ,gBAAgBA,EAAQ,eACnEE,IAAW,KAAK,gBAAgB,IAAIF,EAAQ,gBAAgBA,EAAQ,eACpEG,IAAW,KAAK,gBAAgB,IAAIH,EAAQ,kBAAkBA,EAAQ,iBACtEI,IAAY,KAAK,gBAAgB,IAAIJ,EAAQ,kBAAkBA,EAAQ,iBACvEK,IAAU,KAAK,gBAAgB,IAAIL,EAAQ,gBAAgBA,EAAQ,eACnEM,IAAW,KAAK,gBAAgB,IAAIN,EAAQ,gBAAgBA,EAAQ,eACpEO,IAAa,KAAK,gBAAgB,IAAIP,EAAQ,uBAAuBA,EAAQ,sBAC7EQ,IAAc,KAAK,gBAAgB,IAAIR,EAAQ,uBAAuBA,EAAQ;AACpF,SAAK,WAAW,IAAI,gBAAgBnE,EAAO,gBAAgB;AAAA,MACzD,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,wBAAuB;AAAA,QACjE,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAO,EAAE;AAAA,QAC3C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQE,EAAQ,EAAE;AAAA,QAC5C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQH,EAAQ,sBAAqB,EAAE;AAAA,MACzE;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,mBAAmBnE,EAAO,gBAAgB;AAAA,MAC5D,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,wBAAuB;AAAA,QACjE,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAO,EAAE;AAAA,QAC3C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQE,EAAQ,EAAE;AAAA,QAC5C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQH,EAAQ,yBAAwB,EAAE;AAAA,MAC5E;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,wBAAwBnE,EAAO,gBAAgB;AAAA,MACjE,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,2BAA0B;AAAA,QACpE,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQK,EAAO,EAAE;AAAA,QAC3C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQE,EAAU,EAAE;AAAA,QAC9C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQP,EAAQ,iBAAgB,EAAE;AAAA,MACpE;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,aAAanE,EAAO,gBAAgB;AAAA,MACtD,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,cAAa,EAAE;AAAA,MACjE;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,aAAanE,EAAO,gBAAgB;AAAA,MACtD,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,wBAAuB;AAAA,QACjE,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,gBAAe;AAAA,QACzD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,kBAAiB,EAAE;AAAA,MACrE;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,eAAenE,EAAO,gBAAgB;AAAA,MACxD,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,wBAAuB;AAAA,QACjE,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,2BAA0B;AAAA,QACpE,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,mBAAkB;AAAA,QAC5D,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQO,EAAU,EAAE;AAAA,QAC9C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQP,EAAQ,gBAAe;AAAA,QACzD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,oBAAmB;AAAA,QAC7D,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,cAAa,EAAE;AAAA,MACjE;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,gBAAgBnE,EAAO,gBAAgB;AAAA,MACzD,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,wBAAuB;AAAA,QACjE,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,2BAA0B;AAAA,QACpE,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,mBAAkB;AAAA,QAC5D,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQO,EAAU,EAAE;AAAA,QAC9C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQP,EAAQ,gBAAe;AAAA,QACzD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,oBAAmB;AAAA,QAC7D,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,eAAc,EAAE;AAAA,MAClE;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,eAAenE,EAAO,gBAAgB;AAAA,MACxD,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,wBAAuB;AAAA,QACjE,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,gBAAe;AAAA,QACzD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,UAAS,EAAE;AAAA,MAC7D;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,gBAAgBnE,EAAO,gBAAgB;AAAA,MACzD,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,wBAAuB;AAAA,QACjE,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,2BAA0B;AAAA,QACpE,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,gBAAe;AAAA,QACzD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,iBAAgB;AAAA,QAC1D,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,WAAU,EAAE;AAAA,MAC9D;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,sBAAsBnE,EAAO,gBAAgB;AAAA,MAC/D,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQK,EAAO,EAAE;AAAA,QAC3C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQL,EAAQ,YAAW;AAAA,QACrD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,WAAU;AAAA,QACpD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQM,EAAQ,EAAE;AAAA,MACpD;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,6BAA6BzE,EAAO,gBAAgB;AAAA,MACtE,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQO,EAAU,EAAE;AAAA,QAC9C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQP,EAAQ,aAAY;AAAA,QACtD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQA,EAAQ,WAAU;AAAA,QACpD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQG,EAAQ,EAAE;AAAA,QAC5C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQK,EAAW,EAAE;AAAA,MACvD;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,sBAAsB3E,EAAO,gBAAgB;AAAA,MAC/D,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAO,EAAE;AAAA,QAC3C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQK,EAAQ,EAAE;AAAA;AAAA,QAE5C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQJ,EAAQ,EAAE;AAAA,MACpD;AAAA,IACA,CAAK,CAAC,GACF,KAAK,WAAW,IAAI,wBAAwBrE,EAAO,gBAAgB;AAAA,MACjE,QAAQkE,EAAQ;AAAA,MAChB,SAAS;AAAA,QACP,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQC,EAAQ,SAAQ;AAAA,QAClD,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQG,EAAQ,EAAE;AAAA,QAC5C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQK,EAAW,EAAE;AAAA;AAAA,QAE/C,EAAE,SAAS,GAAG,UAAU,EAAE,QAAQJ,EAAS,EAAE;AAAA,MACrD;AAAA,IACA,CAAK,CAAC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc;AACZ,SAAK,cAAc,IAAI,KAAK,aAC5B,KAAK,iBAAgB;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY;AACV,IAAI,KAAK,kBACP5D,EAAY,KAAK,QAAQ,KAAK,QAAQ,eAAe,KAAK,aAAa,GACvEA,EAAY,KAAK,QAAQ,KAAK,QAAQ,eAAe,KAAK,aAAa,GACvEA,EAAY,KAAK,QAAQ,KAAK,QAAQ,iBAAiB,KAAK,eAAe,GAC3EA,EAAY,KAAK,QAAQ,KAAK,QAAQ,iBAAiB,KAAK,eAAe,GAC3E,KAAK,gBAAgB,KAEnB,KAAK,sBACPA,EAAY,KAAK,QAAQ,KAAK,QAAQ,uBAAuB,KAAK,sBAAsB,GACxF,KAAK,oBAAoB,KAEvB,KAAK,cACPA,EAAY,KAAK,QAAQ,KAAK,QAAQ,UAAU,KAAK,UAAU,GAC/D,KAAK,YAAY,KAEnB,KAAK,mBAAkB;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAIA,qBAAqB;AACnB,UAAME,IAAO,IAAI,aAAa,EAAE;AAChC,IAAAA,EAAK,CAAC,IAAI,KAAK,OAAO,WACtBA,EAAK,CAAC,IAAI,KAAK,OAAO,SACtBA,EAAK,CAAC,IAAI,KAAK,OAAO,QACtBA,EAAK,CAAC,IAAI,KAAK,gBACfA,EAAK,CAAC,IAAI,KAAK,OAAO,eACtBA,EAAK,CAAC,IAAI,KAAK,OAAO,UACtBA,EAAK,CAAC,IAAI,KAAK,OAAO,MACtBA,EAAK,CAAC,IAAI,KAAK,YACfA,EAAK,CAAC,IAAI,KAAK,OAAO,QAAQ,CAAC,GAC/BA,EAAK,CAAC,IAAI,KAAK,OAAO,QAAQ,CAAC,GAC/BA,EAAK,EAAE,IAAI,KAAK,OAAO,QAAQ,CAAC,GAChCA,EAAK,EAAE,IAAI,GACXA,EAAK,EAAE,IAAI,KAAK,OAAO,QAAQ,CAAC,GAChCA,EAAK,EAAE,IAAI,KAAK,OAAO,QAAQ,CAAC,GAChCA,EAAK,EAAE,IAAI,KAAK,OAAO,QAAQ,CAAC,GAChCA,EAAK,EAAE,IAAI,GACXA,EAAK,EAAE,IAAI,KAAK,KAAK,SAAS,CAAC,GAC/BA,EAAK,EAAE,IAAI,KAAK,KAAK,SAAS,CAAC,GAC/BA,EAAK,EAAE,IAAI,KAAK,KAAK,SAAS,CAAC,GAC/BA,EAAK,EAAE,IAAI,GACXA,EAAK,EAAE,IAAI,KAAK,KAAK,WAAW,CAAC,GACjCA,EAAK,EAAE,IAAI,KAAK,KAAK,WAAW,CAAC,GACjCA,EAAK,EAAE,IAAI,KAAK,KAAK,WAAW,CAAC,GACjCA,EAAK,EAAE,IAAI,KAAK,KAAK,qBACrBA,EAAK,EAAE,IAAI,KAAK,kBAAkB,SAAS,GAC3CA,EAAK,EAAE,IAAI,KAAK,kBAAkB,SAAS,GAC3CA,EAAK,EAAE,IAAI,KAAK,kBAAkB,SAAS,GAC3CA,EAAK,EAAE,IAAI,KAAK,kBAAkB;AAClC,UAAM+D,IAAO,IAAI,KAAK,OAAO,SAAS,KAAK,OAAO;AAClD,IAAA/D,EAAK,EAAE,IAAI+D,GACX/D,EAAK,EAAE,IAAI+D,GACX/D,EAAK,EAAE,IAAI+D,GAEX/D,EAAK,EAAE,IAAI,KAAK,cAAc,GAC9BF,EAAY,KAAK,QAAQ,KAAK,QAAQ,QAAQE,CAAI;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ/E,GAAGC,GAAGC,GAAGwB,GAAIC,GAAIC,GAAIC,GAAIkH,GAAMC,GAAUC,GAAUC,GAAU;AACnE,QAAI,KAAK,cAAc,KAAK;AAC1B,qBAAQ,KAAK,6BAA6B,KAAK,SAAS,WAAW,GAC5D;AAET,UAAMC,IAAK,KAAK,YACVnE,IAASmE,IAAK;AACpB,gBAAK,cAAcnE,CAAM,IAAIhF,GAC7B,KAAK,cAAcgF,IAAS,CAAC,IAAI/E,GACjC,KAAK,cAAc+E,IAAS,CAAC,IAAI9E,GACjC,KAAK,cAAc8E,IAAS,CAAC,IAAI,GACjC,KAAK,gBAAgBA,CAAM,IAAItD,GAC/B,KAAK,gBAAgBsD,IAAS,CAAC,IAAIrD,GACnC,KAAK,gBAAgBqD,IAAS,CAAC,IAAIpD,GACnC,KAAK,gBAAgBoD,IAAS,CAAC,IAAInD,GACnC,KAAK,WAAWmD,CAAM,IAAIgE,IAAW,IAAI,IAAIA,IAAW,GACxD,KAAK,WAAWhE,IAAS,CAAC,IAAIiE,IAAW,IAAI,IAAIA,IAAW,GAC5D,KAAK,WAAWjE,IAAS,CAAC,IAAIkE,IAAW,IAAI,IAAIA,IAAW,GAC5D,KAAK,WAAWlE,IAAS,CAAC,IAAI+D,IAAO,IAAI,IAAIA,IAAO,GACpD,KAAK,cACL,KAAK,gBAAgB,IACrB,KAAK,YAAY,IACVI;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,YAAYC,GAAQpJ,GAAGC,GAAGC,GAAG;AAC3B,QAAI,KAAK,kBAAkB,KAAK;AAC9B,qBAAQ,KAAK,iCAAiC,KAAK,YAAY,WAAW,GACnE;AAET,UAAMiJ,IAAK,KAAK,gBACVnE,IAASmE,IAAK;AACpB,gBAAK,uBAAuBnE,CAAM,IAAIhF,GACtC,KAAK,uBAAuBgF,IAAS,CAAC,IAAI/E,GAC1C,KAAK,uBAAuB+E,IAAS,CAAC,IAAI9E,GAC1C,KAAK,uBAAuB8E,IAAS,CAAC,IAAIoE,GAC1C,KAAK,kBACL,KAAK,oBAAoB,IAClBD;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,KAAKE,GAAW;AACd,QAAI,CAAC,KAAK,aAAa;AACrB,cAAQ,KAAK,wDAAwD;AACrE;AAAA,IACF;AACA,SAAK,eAAeA;AACpB,QAAIC,IAAW;AACf,WAAO,KAAK,eAAe,KAAK,OAAO,iBAAiBA,IAAW,KAAK;AACtE,WAAK,WAAU,GACf,KAAK,eAAe,KAAK,OAAO,eAChCA;AAEF,SAAK,sBAAsB,KAAK,cAAc,KAAK,OAAO,eAC1D,KAAK,QAAQD;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAIA,aAAa;AACX,SAAK,UAAS;AACd,UAAME,IAAU,KAAK,OAAO,qBAAqB,EAAE,OAAO,gBAAgB;AAC1E,IAAAA,EAAQ,YAAY,KAAK,QAAQ,SAAS,GAC1CA,EAAQ,YAAY,KAAK,QAAQ,UAAU,GAC3CA,EAAQ,YAAY,KAAK,QAAQ,iBAAiB;AAClD,UAAMC,IAAmBhE,EAAgB,KAAK,gBAAgBiB,CAAc,GACtEgD,IAAejE,EAAgB,KAAK,YAAYiB,CAAc;AAEpE;AACE,YAAMiD,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,iBAAgB,CAAE;AACjE,MAAAG,EAAK,YAAY,KAAK,UAAU,YAAY,GAC5CA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,cAAc,CAAC,GACxDA,EAAK,mBAAmBF,CAAgB,GACxCE,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,oBAAmB,CAAE;AACpE,MAAAG,EAAK,YAAY,KAAK,UAAU,eAAe,GAC/CA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,iBAAiB,CAAC,GAC3DA,EAAK,mBAAmBF,CAAgB,GACxCE,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,2BAA0B,CAAE;AAC3E,MAAAG,EAAK,YAAY,KAAK,UAAU,oBAAoB,GACpDA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,sBAAsB,CAAC,GAChEA,EAAK,mBAAmBF,CAAgB,GACxCE,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,aAAY,CAAE;AAC7D,MAAAG,EAAK,YAAY,KAAK,UAAU,SAAS,GACzCA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,WAAW,CAAC,GACrDA,EAAK,mBAAmB,KAAK,aAAa,GAAG,KAAK,aAAa,GAAG,KAAK,aAAa,CAAC,GACrFA,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,aAAY,CAAE;AAC7D,MAAAG,EAAK,YAAY,KAAK,UAAU,SAAS,GACzCA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,WAAW,CAAC,GACrDA,EAAK,mBAAmBF,CAAgB,GACxCE,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,eAAc,CAAE;AAC/D,MAAAG,EAAK,YAAY,KAAK,UAAU,WAAW,GAC3CA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,aAAa,CAAC,GACvDA,EAAK,mBAAmBF,CAAgB,GACxCE,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,gBAAe,CAAE;AAChE,MAAAG,EAAK,YAAY,KAAK,UAAU,YAAY,GAC5CA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,cAAc,CAAC,GACxDA,EAAK,mBAAmBF,CAAgB,GACxCE,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,eAAc,CAAE;AAC/D,MAAAG,EAAK,YAAY,KAAK,UAAU,WAAW,GAC3CA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,aAAa,CAAC,GACvDA,EAAK,mBAAmBF,CAAgB,GACxCE,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,gBAAe,CAAE;AAChE,MAAAG,EAAK,YAAY,KAAK,UAAU,YAAY,GAC5CA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,cAAc,CAAC,GACxDA,EAAK,mBAAmBF,CAAgB,GACxCE,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,uBAAsB,CAAE;AACvE,MAAAG,EAAK,YAAY,KAAK,UAAU,kBAAkB,GAClDA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,oBAAoB,CAAC,GAC9DA,EAAK,mBAAmBD,CAAY,GACpCC,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,+BAA8B,CAAE;AAC/E,MAAAG,EAAK,YAAY,KAAK,UAAU,yBAAyB,GACzDA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,2BAA2B,CAAC,GACrEA,EAAK,mBAAmBD,CAAY,GACpCC,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,uBAAsB,CAAE;AACvE,MAAAG,EAAK,YAAY,KAAK,UAAU,kBAAkB,GAClDA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,oBAAoB,CAAC,GAC9DA,EAAK,mBAAmBD,CAAY,GACpCC,EAAK,IAAG;AAAA,IACV;AACA;AACE,YAAMA,IAAOH,EAAQ,iBAAiB,EAAE,OAAO,yBAAwB,CAAE;AACzE,MAAAG,EAAK,YAAY,KAAK,UAAU,oBAAoB,GACpDA,EAAK,aAAa,GAAG,KAAK,WAAW,IAAI,sBAAsB,CAAC,GAChEA,EAAK,mBAAmBD,CAAY,GACpCC,EAAK,IAAG;AAAA,IACV;AACA,SAAK,OAAO,MAAM,OAAO,CAACH,EAAQ,OAAM,CAAE,CAAC,GAC3C,KAAK,YAAW,GAChB,KAAK,aAAa,KAAK,OAAO;AAAA,EAChC;AAAA;AAAA,EAEA,IAAI,YAAY;AACd,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,gBAAgB;AAClB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAIA,iCAAiC;AAC/B,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA;AAAA,EAEA,4BAA4B;AAC1B,WAAO,KAAK,+BAA8B;AAAA,EAC5C;AAAA,EACA,kBAAkB;AAChB,WAAO,KAAK,QAAQ;AAAA,EACtB;AAAA,EACA,IAAI,qBAAqB;AACvB,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,YAAY;AACd,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EACA,IAAI,UAAUpJ,GAAG;AACf,SAAK,OAAO,YAAYA;AAAA,EAC1B;AAAA,EACA,IAAI,UAAU;AACZ,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EACA,IAAI,QAAQA,GAAG;AACb,SAAK,OAAO,UAAUA;AAAA,EACxB;AAAA,EACA,IAAI,WAAW;AACb,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EACA,IAAI,SAASA,GAAG;AACd,SAAK,OAAO,WAAWA;AAAA,EACzB;AAAA,EACA,IAAI,OAAO;AACT,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EACA,IAAI,KAAKA,GAAG;AACV,SAAK,OAAO,OAAOA;AAAA,EACrB;AAAA,EACA,IAAI,SAAS;AACX,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EACA,IAAI,OAAOA,GAAG;AACZ,SAAK,OAAO,SAASA;AAAA,EACvB;AAAA,EACA,IAAI,gBAAgB;AAClB,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EACA,IAAI,cAAcA,GAAG;AACnB,SAAK,OAAO,gBAAgBA;AAAA,EAC9B;AAAA,EACA,IAAI,UAAU;AACZ,WAAO,IAAIJ,EAAK,KAAK,OAAO,QAAQ,CAAC,GAAG,KAAK,OAAO,QAAQ,CAAC,GAAG,KAAK,OAAO,QAAQ,CAAC,CAAC;AAAA,EACxF;AAAA,EACA,IAAI,QAAQI,GAAG;AACb,SAAK,OAAO,QAAQ,CAAC,IAAIA,EAAE,GAC3B,KAAK,OAAO,QAAQ,CAAC,IAAIA,EAAE,GAC3B,KAAK,OAAO,QAAQ,CAAC,IAAIA,EAAE;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAIA,kBAAkBwJ,GAAO3J,GAAGC,GAAGC,GAAG;AAChC,QAAIyJ,MAAU,EAAG,OAAM,IAAI,MAAM,oCAAoC;AACrE,SAAK,kBAAkB,SAAS,IAAI3J,GAAGC,GAAGC,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAIA,kBAAkByJ,GAAO7I,GAAK;AAC5B,QAAI6I,MAAU,EAAG,OAAM,IAAI,MAAM,oCAAoC;AACrE,WAAA7I,IAAMA,KAAO,IAAIf,EAAI,GACrBe,EAAI,KAAK,KAAK,kBAAkB,QAAQ,GACjCA;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAIA,gBAAgB6I,GAAOC,GAAQ;AAC7B,QAAID,MAAU,EAAG,OAAM,IAAI,MAAM,oCAAoC;AACrE,SAAK,kBAAkB,SAASC;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAIA,gBAAgBD,GAAO;AACrB,QAAIA,MAAU,EAAG,OAAM,IAAI,MAAM,oCAAoC;AACrE,WAAO,KAAK,kBAAkB;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,oBAAoB;AACxB,UAAMlF,IAAO,KAAK,aAAa,IAAI,GAC7BoF,IAAY,KAAK,gBAAgB,IAAI,KAAK,QAAQ,gBAAgB,KAAK,QAAQ,eAC/E9E,IAAO,MAAME,EAAW,KAAK,QAAQ4E,GAAW,KAAK,QAAQ,iBAAiBpF,CAAI;AACxF,WAAO,IAAI,aAAaM,CAAI;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,sBAAsB;AAC1B,UAAMN,IAAO,KAAK,aAAa,IAAI,GAC7BqF,IAAa,KAAK,gBAAgB,IAAI,KAAK,QAAQ,kBAAkB,KAAK,QAAQ,iBAClF/E,IAAO,MAAME,EAAW,KAAK,QAAQ6E,GAAY,KAAK,QAAQ,mBAAmBrF,CAAI;AAC3F,WAAO,IAAI,aAAaM,CAAI;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY;AACV,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAIA,wBAAwB;AACtB,WAAO,KAAK,gBAAgB,IAAI,KAAK,QAAQ,gBAAgB,KAAK,QAAQ;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA,EAIA,0BAA0B;AACxB,WAAO,KAAK,gBAAgB,IAAI,KAAK,QAAQ,kBAAkB,KAAK,QAAQ;AAAA,EAC9E;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU;AACR,IAAK,KAAK,gBACV,OAAO,OAAO,KAAK,OAAO,EAAE,QAAQ,CAACD,MAAW;AAC9C,MAAIA,KAAU,OAAOA,EAAO,WAAY,cACtCA,EAAO,QAAO;AAAA,IAElB,CAAC,GACD,KAAK,WAAW,MAAK,GACrB,KAAK,cAAc;AAAA,EACrB;AACF;ACv1BK,MAACiF,IAAU;"}